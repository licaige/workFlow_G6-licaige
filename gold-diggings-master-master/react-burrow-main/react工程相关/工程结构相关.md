>在路上。

- 1.代码结构相关，react工程代码如何组织。

>[参考链接](https://segmentfault.com/a/1190000019759949)

- 2.组件不需要过渡封装，如果嵌套的太深，会影响代码维护。

- 3.不要偷懒/多思考/重构/消除重复代码，你的能力就会慢慢提升。

- 4.单一职责的好处：

>1.降低组件的复杂度，职责单一组件代码量少，容易被理解，可读性高。

>2.降低对其他组件的耦合。当变更到来时可以降低对其他功能的影响，不至于牵一发而动全身。

>3.提高可复用性，功能越单一可复用性越高，就比如一些基础组件。

- 5.高质量组件的特性：高内聚，低耦合。

- 6.写react代码的一些基本技巧：

>1.如果组件不需要状态，则使用无状态组件。

>2.性能上比较：无状态函数>有状态函数>class组件。

>3.最小化props（接口），不要传递超过要求的props。

>4.如果组件内部存在较多条件控制流，这通常意味着需要对组件进行抽取。

>5.不要过早优化，只要求组件在当前需求下可被复用，然后随机应变。

- 7.典型结构

```
node_modules/antd/     🔴 通用的组件库, 不能和任何项目的业务耦合
src/
  components/          🔴 项目通用的组件库, 可以被多个容器/页面组件共享
  containers/
    Foo/
      components/      🔴 容器/页面组件特有的组件库, 和一个业务/功能深度耦合. 以致于不能被其他容器组件共享
      index.tsx
    Bar/
      components/
      index.tsx
```

- 8.对于展示组件，我们要以一种第三方组件库的标准来考虑组件的设计，减少与业务的耦合度，考虑各种应用的场景，设计好公开的接口。

- 9.容器组件主要关注业务处理，容器组件一般以高阶组件形式存在，它一般从外部数据源（redux这些状态管理器或者直接请求服务端数据）获取数据，然后组合展示组件来构建完整的视图。

- 10.容器组件通过组合展示组件来构建完整视图，但两者未必是简单的包含与被包含的关系。容器组件和展示组件分离可以带来的好处主要是可复用性和可维护性。

- 11.容器组件和展示组件分离的好处：

>1.可复用性：展示组件可以用于多个不同的数据源（容器组件），容器组件（业务逻辑）也可以被复用于不同平台的展示组件。

>2.展示和容器组件更好的分离，有助于更好的理解应用和UI，两者可以被独立地维护。

>3.展示组件变得轻量（无状态/或局部状态），更容易被测试。

- 12.如果组件不需要状态，那尽量用无状态组件。

- 13.分离逻辑和视图。

- 14.分离逻辑和视图的主要方式有：

>1.hooks。

>2.高阶组件。

>3.Render Props。

>4.Context。

- 15.无状态组件内部不存储状态，完全由外部的props来映射，这类组件以函数组件形式存在，作为低级/高复用的底层展示型组件。无状态组件天然就是纯组件，如果无状态组件的映射需要一点成本，可以使用React.memo包裹避免重复渲染。

- 16.纯组件，没有副作用，相同的输入只会得到相同的输出结果，输出只跟输入有关，不依赖于其他的状态。

- 17.纯组件对React的性能优化也有重要意义。如果一个组件时一个纯组件，如果输入没有变动，那么这个组件就不需要重新渲染，组件树越大，纯组件带来的性能优化收益就越高。

- 18.我们可以很容易地保证一个底层组件地纯净性，因为它本来就很简单，但是对于一个复杂的组件树，则需要花点心思进行构建，所以就有了状态管理的需求，这些状态管理器通常都在组件树的外部维护一个和或多个状态库，然后通过依赖注入形式，将局部的状态注入到子树中，通过视图和逻辑分离的原则，来维持组件树的纯净性。

- 19.Redux就是一个典型的解决方案，在Redux的世界里可以认为一个复杂的组件树就是一颗状态树的映射，只要状态树（需要依靠不可变数据来保持状态的可预测性）不变，组件树就不变。Redux建议保持组件的纯净性，将组件状态交给Redux和配套的异步处理工具来维护，这样就将整个应用抽象成了一个单向的数据流，这是一种简单的输入/输出关系。

>一个复杂的组件树是一颗状态树的映射。

- 20.不管是Cyclejs还是Redux，抽象是需要付出一点代价的，就比如redux代码可能会很啰嗦，一个复杂的状态树，如果缺乏良好的组织，整个应用会变得很难理解。实际上，并不是所有场景都能够顺利/优雅通过数据驱动进行表达，例如文本框焦点，或者模态框，所以不必极端追求无副作用或者数据驱动。

- 21.分离布局组件和内容组件。

- 22.将布局从内容组件中抽取出来，分离布局和内容，可以让两者更好维护，比如布局变动不会影响内容，内容组件可以被应用不同的布局；另一方面组件是一个自包含内聚的隔离单元，不应该影响其外部的状态，例如一个按钮不应该修改外部的布局，另外也要避免影响全局的样式。

- 23.开发的过程中需注意表单组件，因为表单组件本身的一些特性与其他组件还是有一定的区别。

- 24.典型的React目录结构：

```
src/
  components/      # 🔴 项目通用的‘展示组件’
    Button/
      index.tsx    # 组件的入口, 导出组件
      Groups.tsx   # 子组件
      loading.svg  # 静态资源
      style.css    # 组件样式
    ...
    index.ts       # 到处所有组件
  containers/      # 🔴 包含'容器组件'和'页面组件'
    LoginPage/     # 页面组件, 例如登录
      components/  # 页面级别展示组件，这些组件不能复用与其他页面组件。
        Button.tsx # 组件未必是一个目录形式，对于一个简单组件可以是一个单文件形式. 但还是推荐使用目录，方便扩展
        Panel.tsx
      reducer.ts   # redux reduces
      useLogin.ts  # (可选)放置'逻辑', 按照👆分离逻辑和视图的原则，将逻辑、状态处理抽取到hook文件
      types.ts     # typescript 类型声明
      style.css
      logo.png
      message.ts
      constants.ts
      index.tsx
    HomePage/
    ...
    index.tsx      # 🔴应用根组件
  hooks/           # 🔴可复用的hook
    useList.ts
    usePromise.ts
  ...
  index.tsx        # 应用入口, 在这里使用ReactDOM对跟组件进行渲染
  stores.ts        # redux stores
  contants.ts      # 全局常量
```

- 25.前端项目一般按照页面路由来拆分组件，这些组件我们暂且称为页面组件，这些组件是和业务功能耦合的，而且每个页面之间具有一定的独立性。

- 26.多页应用目录结构：

```
src/
  components/       # 共享组件
  containers/
    Admin/          # 后台管理页面
      components/   # 后台特定的组件库
      LoginPage/
      index.tsx
      ...
    App/
      components/  # App特定的组件库
      LoginPage/   # App页面
      index.tsx
      stores.ts    # redux stores
    AnotherApp/    # 另外一个App页面
  hooks/
  ...
  app.tsx          # 应用入口
  anotherApp.tsx   # 应用入口
  admin.tsx        # 后台入口
```

- 27.利用webpack的SplitChunksPlugin可以自动为多页应用抽取共享的模块，这个对于功能差不多和有较多共享代码的多页应用很有意义，意味着资源被一起优化，抽取共享模块，有利于减少编译文件体积，也便于共享浏览器缓存。

>html-webpack-plugin4.0开始支持注入共享chunk，在此之前需要通过SplitChunksPlugin显式定义共享的chunk，然后也要html-webpack-plugin显示注入该chunk。

- 28.上面的多页目录会存在一些问题：

>1.不能允许不同页面有不同版本的依赖。

>2.对于毫无相关的应用，这种组织方式会让代码变得混乱，例如App和后台，他们使用的技术栈/组件库/交互体验都可能相差较大，而且容易造成命名冲突。

>3.构建性能，你希望单独对某个页面进行构建和维护，而不是所有页面混合在一起构建。

>这种场景上我们就可以使用lerna或者monorepo机制，将多页应用隔离在不同的npm模块下。lerna和monorepo的应用场景。

- 29.架构，格局。

- 30.抽象是有代价的，平衡，取舍。

- 31.如何规范的组织工程里的模块。

- 32.一个模块只有一个统一的出口。

- 33.一个目录就是一个模块的边界。

- 34.一个模块/目录应该由一个出口文件来统一管理模块的导出，限定模块的可见性。

>每个文件下需要一个index.js文件。

- 35.当其他模块依赖某个模块的细节时，可能是一种重构的信号：比如依赖一个模块的一个工具函数或者是一个对象类型声明，这时候可能应该将其抬升到父级模块，让兄弟模块共享它。

- 36.在前端项目中index文件最适合作为一个出口文件，当导入一个目录时，模块查找器会查找该目录下是否存在的index文件，开发者设计一个模块的API时，需要考虑模块各种使用方式，并使用index文件控制模块可见性。

- 37.不是所有目录都有出口文件，这时候目录就不是模块的边界了，典型的有utils，utils只是一个模块命名空间，utils下面的文件都是一些互不相关或者不同类型的文件。

- 38.我们习惯直接引用utils下面的文件，而不是通过一个入口文件，这样可以更明确导入的是什么类型的。

- 39.一个模块可以访问兄弟（同个作用域下）、祖先及祖先的兄弟模块。 

- 40.named export和export default的区别。

>1.在一个文件模块中，named export可以有多个，而export default只能有一个。

>2.通过named export导出的，导入的时候需要使用{}进行导入。

>3.named export可以导出表达式，而export default则不可以。

>4.export default更加的简洁。

- 41.对于主体对象明确的模块需要有默认导出，例如页面组件，类。

- 42.对于主体对象不明确的模块不应该使用默认导出，例如组件库、utils、contants常量。

- 43.React开发规范。

- 44.components下面应该有index出口吗？

- 45.相对路径不要超过2级。

- 46.当项目越来越复杂，目录可能会越来越深，这时候会出现这样的导入路径。

```javascript
import { hide } from '../../../utils/dom'
```

- 47.所以一般推荐相对路径导入不应该超过2级，即只能是../和./可以尝试将相对路径转换成绝对路径形式，例如webpack中可以配置resolve.alias属性来实现。

```javascript
    ...
    resolve: {
      ...
      alias: {
        // 可以直接使用~访问相对于src目录的模块
        // 如 ~/components/Button
        '~': context,
      },
    }
```

```javascript
import { hide } from '~/utils/dom';
```

- 48.超过300行则说明需要对这个组件进行进一步拆分。

- 49.组件划分。可以根据原型图进行划分。

- 50.组件命名，可以参考UI组件库的命名方式。

- 51.设计组件的状态。

- 52.文档：Storybook。

- 53.原子设计。
