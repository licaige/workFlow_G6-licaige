树是一种数据结构，比如：目录结构

树是一种可以递归定义的数据结构

树是由n个节点组成的集合

如果n=0，那这是一棵空树

如果n>0，那存在1个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身又是一颗树

根节点：的概念就是 头

叶子节点：就是不能分叉，就是最后一个，叶子吗，叶子，下面没有孩子了

树的深度（高度）：，最深有几层

树的度：（分几个叉）看往下的。 整个树的度（看整个树的度分几个叉，分最多的几个叉，就是几）

父节点，子节点

子树：在大树下的子树，扒下来

> 什么是二叉树

度不超过2的数

二叉树：度不超过2的树

每个节点最多有两个孩子节点

两个孩子节点被区分为 左孩子节点 和 右孩子节点

> 满二叉树：

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树

> 完全二叉树：

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。

> 二叉树的存储方式（表示方式）

1，链式存储方式
2，顺序存储方式

> 二叉树的顺序存储方式

父亲找孩子，孩子找父亲。

父节点和左孩子节点的编号下标有什么关系
0-1 1-3 2-5 3-7 4-9

i->2i+1

父节点和右孩子节点的编号下标有什么关系
0-2 1-4 2-6 3-8 4-10

i->2i+2

> 堆排序

堆：一种特殊的完全二叉树结构

大根堆：一棵完全二叉树，满足任一节点都比其孩子节点大

小根堆：一棵完全二叉树，满足任一节点都比其孩子节点小

> 堆的向下调整

当根节点的左右子树都是堆时，可以通过一次向下的调整来将其变换成一个堆。

> 堆排序过程

1，建立堆
2，得到堆顶元素，为最大元素
3，去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序。
4，堆顶元素为第二大元素
5，重复步骤3，直到堆变空

> 实现

li:列表
low:堆的根节点位置
high:堆的最后一个元素的位置
return

```
def sift(li, low, high):
 i = low # 最开始指向根节点
 j = 2*i+1 # j开始是左孩子
 tmp = li[low] # 把堆顶存起来
 while j <= high: # 只要j位置有数
  if j + 1 <= high and li[j+1] > li[j]: # 如果右孩子有并且比较大
   j = j + 1 # 指向右孩子
  if li[j] > tmp:
   li[i] = li[j]
   i = j # 往下看一层
   j = 2 * i + 1
  else: # tmp 更大，把tmp放到i的位置上
   li[i] = tmp # 把tmp放到某一级领导位置上
   break
 else: 
  li[i] = tmp # 把tmp放到叶子节点上
```

```
def sift(li, low, high):
 i = low # 最开始指向根节点
 j = 2*i+1 # j开始是左孩子
 tmp = li[low] # 把堆顶存起来
 while j <= high: # 只要j位置有数
  if j + 1 <= high and li[j+1] > li[j]: # 如果右孩子有并且比较大
   j = j + 1 # 指向右孩子
  if li[j] > tmp:
   li[i] = li[j]
   i = j # 往下看一层
   j = 2 * i + 1
  else: # tmp 更大，把tmp放到i的位置上
   break
 li[i] = tmp
```

