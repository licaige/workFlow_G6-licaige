// 1.为什么要加密？https加密原理
// 因为http是明文传输的，明文传输的过程中会有路由器，wifi热点，通信服务等多个物理节点，如果信息在过程中被劫持，传输的内容就完全暴露了，挟持者还可以任意篡改传输的信息不被双方察觉，这就是中间人攻击。

// 2.加密方式
// 一、对称加密（有一个密钥，可以解密加密）
// 如果双方都持有一个密钥，并且密钥不被其他人知道，那这两方的安全是可以被保证的。
// 最大的问题就是，这个密钥如何传输不被别人知道，如果服务器生成一个密钥并且传输给浏览器，那么这个过程中密钥被别人劫持到手了怎么办？所以就需要非对称加密

// 二、非对称加密
// 浏览器和客户端都拥有一把私钥公钥，服务器用明文把自己的公钥传给浏览器，浏览器也把自己的公钥传给服务器。每次服务器要传递数据给浏览器就用浏览器自己的公钥加密，浏览器收到后用自己的私钥解密。
// 但是非对称加密算法非常耗时，而对称加密会快很多。

// 三、非对称加密 + 对称加密（https）
//       服务器拥有一组 公钥A 私钥A'。
// 浏览器向服务器发送请求，服务器把明文的公钥A返还给浏览器
// 浏览器随机生成一个用于对称加密的密钥X, 使用公钥A加密后传给服务器
//       服务器用私钥A'解密得到密钥X
// 这样双方都拥有密钥X了
      
//       但是有漏洞 谨防中间人攻击！！！
//       比如 浏览器向服务器发送请求，服务器把明文的公钥A发给了浏览器
// 如果中间人劫持这条数据，把公钥A保存下来，把数据包的公钥A，替换为自己的公钥B，等到浏览器收到数据，（浏览器并不知道钥匙已经被替换了），用中间人给的公钥B对密钥X进行了加密，然后中间人又劫持了浏览器发送给服务器的数据，用自己的私钥B解密了浏览器的密钥X，然后再用服务器的公钥加密数据返回给服务器，神不知鬼不觉的拿到了密钥X，
// 服务器也通过自己的私钥A，拿到了密钥X

// 这下需要证明的是，公钥是来自哪儿（CA机构）数字证书
// 前提：网站在使用https前，需要像CA机构申领一个数字证书，数字证书里面有持有者信息、公钥信息等。
// 服务器把证书传给浏览器，浏览器从证书里面获取公钥，证书就如身份证（证明该公钥对应该网站）

// 如何防止证书被篡改（数字签名）
// 我们把证书原本的内容生成一份（签名），比对证书和签名是否一致就能判别是否被篡改。这就是数字签名的防伪技术

// 数字签名
// 1.CA机构拥有非对称加密和非对称加密的私钥和公钥
// 2.CA机构对证书明文数据T进行了Hash
// 3.对hash后的值用签名者的私钥加密，得到数字签名S
// 4.数组签名和认证组成数字证书，这样一份数字证书就可以颁发给网站了

// 浏览器的验证过程
// 1.拿到证书，得到明文T，签名S
// 2.用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥）得到S‘
// 3.用证书里指明的hash算法进行hash得到T'
// 4.如果T'等到S'，除非明文或签名被篡改，所以此时比较S'是否等于T‘，等于则表示证书可信

// 中间人有可能篡改证书吗？
// 1.中间人没有CA机构的私钥，无法得到加密后的签名，无法相应的篡改签名。浏览器收到该证书后就会发现原文和解密的不一致，说明证书被篡改

// 中间人可能调包证书吗？
// 假设B网站也拿到了CA机构认证的证书，他想劫持网站A的信息。于是它称为中间人拦截了传给A网站的证书，然后替换成B网站的证书，传给浏览器，之后浏览器就会拿到B的证书了？
// 其实并不会发生，因为证书包含了A的网址域名，浏览器把证书里的域名和自己请求的域名对比一下就知道调包没有

// 为什么制作数字证书需要Hash一下
// 因为有性能问题，非对称加密性能差，证书一般信息比较长，比较耗时。而hash得到的是固定长度的信息（比如md5算法可以得到固定的128位的值），这样加解密快很多。

// 怎么证明CA机构的公钥是可信的？
// 浏览器会预装一些他们信任的根证书，如果其中有CA机构的根证书，这样就可以拿到它对应的可信公钥了。实际上证书的认证也不止一层，可以信任A，A信任B，B信任C，这是信任链条或者数字证书链。也就是一连串的数字证书，以根证书为起点，透过层层信任，使得终端实体证书的持有者可以获得信任，证明身份。
//       有时候有些网站 也必须安装证书才可以访问，说明浏览器还没给这个机构颁发证书，需要你自己安装，风险自己承担。安装后就获得它的公钥。就可以验证服务器发来的证书是否可信了。

// 每次进行https请求的时候都必须在SSL / TLS层进行握手传输密钥吗？
// 服务器会给每个浏览器维护一个sessionID，在TLS握手阶段传给浏览器。
// 浏览器生成密钥传给服务器后，服务器会把这个密钥传到sessionID下，之后每次浏览器的请求都会携带sessionID，服务器会根据sessionID找到相应的密钥并进行加解密操作。就不必重新制作和传输密钥了。
