<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // const PENDING = 'pending';
        // const FULFILLED = 'fulfilled';
        // const REJECTED = 'rejected';

        // function Promise(execute) {
        //     let that = this;
        //     that.status = PENDING;
        //     that.onFulfilledFn = [];
        //     that.onRejectedFn = [];
        //     function resove(value) {
        //         setTimeout(function () {
        //             if (that.status === PENDING) {
        //                 that.status = FULFILLED;
        //                 that.value = value;
        //                 that.onFulfilledFn.forEach(fn => {
        //                     fn(that.value)
        //                 })
        //             }
        //         })
        //     }
        //     function reject(reason) {
        //         setTimeout(function () {
        //             if (that.status === PENDING) {
        //                 that.status = REJECTED;
        //                 that.reason = reason;
        //                 that.onRejectedFn.forEach(fn => {
        //                     fn(that.value)
        //                 })
        //             }
        //         })
        //     }
        //     try {
        //         execute(resove, reject);
        //     } catch (error) {
        //         reject(error)
        //     }
        // }
        // Promise.prototype.then = function (onFulfilled, onRejected) {
        //     onFulfilled =
        //         typeof onFulfilled === 'function'
        //             ? onFulfilled
        //             : function (x) {
        //                 return x
        //             }
        //     onRejected =
        //         typeof onRejected === 'function'
        //             ? onRejected
        //             : function (x) {
        //                 return x
        //             }
        //     let that = this;
        //     let Promise;
        //     if (that.status === FULFILLED) {
        //         promise = new Promise(function (resolve, reject) {
        //             setTimeout(function () {
        //                 try {
        //                     let x = onFulfilled(that.value);
        //                 } catch (reason) {
        //                     reject(reason)
        //                 }
        //             })
        //         })
        //     }
        //     if (that.status === REJECTED) {
        //         promise = new Promise(function (resolve, reject) {
        //             setTimeout(function () {
        //                 try {
        //                     let x = onRejected(that.reason);
        //                 } catch (reason) {
        //                     reject(reason)
        //                 }
        //             })
        //         })
        //     }

        //     if (that.status === PENDING) {
        //         promise = new Promise(function (resolve, reject) {
        //             that.onFulfilled.push(function () {
        //                 try {
        //                     let x = onFulfilled(that.value);
        //                     resolvePromise(promise, x, reslove, reject)
        //                 } catch (reason) {
        //                     reject(reason)
        //                 }
        //             });
        //             that.onRejected.push(function () {
        //                 try {
        //                     let x = onRejected(that.reason);
        //                     resolvePromise(promise, x, reslove, reject)
        //                 } catch (error) {
        //                     reject(reason)
        //                 }
        //             })
        //         })
        //     }
        //     return promise;
        // }

        // function resolvePromise(promise, x, resolve, reject) {
        //     if (promise === x) {
        //         return reject(new TypeError('x不能与Promise相等'))
        //     }
        //     if (x instanceof Promise) {
        //         if (x.status === FULFILLED) {
        //             resolve(x.value)
        //         } else if (x.status === REJECTED) {
        //             reject(x.reason)
        //         } else {
        //             x.then(function (y) {
        //                 resolvePromise(promise, y, resolve, reject)
        //             }, reject)
        //         }
        //     } else if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
        //         let executed;
        //         try {
        //             let then = x.then;
        //             if (typeof then === 'function') {
        //                 then.call(x, function (y) {
        //                     if (execute) return;
        //                     execute = true;
        //                     resolvePromise(promise, y, resolve, reject)
        //                 }, function (e) {
        //                     if (execute) return;
        //                     execute = true;
        //                     reject(e);
        //                 })
        //             } else {
        //                 reslove(x);
        //             }
        //         } catch (e) {
        //             if (execute) return;
        //             executed = true;
        //             reject(e);
        //         }
        //     } else {
        //         resove(x)
        //     }
        // }

        // let p = new Promise((resolve, reject) => resolve('解决'));
        // console.log(p);

        // function myPromise(execute) {
        //     let that = this;
        //     that.status = PENDING;
        //     function resolve(value) {
        //         if (that.status === PENDING) {
        //             that.status = FULFILLED;
        //             that.value = value;
        //         }
        //     }
        // }
        // let p1 = new myPromise((resolve, reject) => resolve('解决'));
        // console.log(p1);

        // const PENDING = 'pending';
        // const FULFILLED = 'fulFilled';
        // const REJECTED = 'rejected';

        // function myPromise(execute) {
        //     let _that = this;
        //     _that.state = PENDING;
        //     function resolve(value) {
        //         if (_that.state === PENDING) {
        //             _that.state = FULFILLED;
        //             _that.value = value;
        //         }
        //     }
        // }
        // let p = new myPromise((resolve, reject) => resolve('解决'));
        // console.log(p);


        // let p0 = new Promise((resolve, reject) => {
        //     resolve('XKHM')
        // })
        // console.log(p0);
        // let p01 = new Promise((resolve, reject) => {
        //     reject('XKHM')
        // })
        // console.log(p01);
        // class MyPromise {
        //     const PENDING = 'pending';
        //     const FULFILLED = 'fulFilled';
        //     const REJECTED = 'rejected';
        //     constructor(executor) {
        //         this.status = MyPromise.PENDING;
        //         this.value = null;
        //         try {
        //             // 这个地方this.resolve只是拿到resolve方法，并不是this调用的
        //             // 事实上是全局对象调用的，但是class里面默认是严格模式
        //             // 如果不改变resolve的内部this指向，他的this是undefined
        //             executor(this.resolve.bind(this), this.reject.bind(this));
        //         } catch (error) {
        //             this.reject(error)
        //         }
        //     }
        //     resolve(value) {
        //         if (this.status === MyPromise.PENDING) {
        //             this.status = MyPromise.FULFILLED;
        //             this.value = value;
        //         }
        //     }
        //     reject(reason) {
        //         if (this.status === MyPromise.PENDING) {
        //             this.status = MyPromise.REJECTED;
        //             this.reason = reason;
        //         }
        //     }
        // }
        // // 测试
        // let p = new MyPromise(function (resolve, reject) {
        //     reject('XKHM')
        // });
        // console.log(p);

        // function MyPromise(executor) {
        //     const PENDING = 'pending';
        //     const FULFILLED = 'fulFilled';
        //     const REJECTED = 'rejected';
        //     const _that = this;
        //     _that.status = PENDING;
        //     try {
        //         executor(resolve, reject)
        //     } catch (error) {
        //         reject(error)
        //     }
        //     function resolve(value) {
        //         if (_that.status === PENDING) {
        //             _that.status = FULFILLED;
        //             _that.value = value;
        //         }
        //     }
        //     function reject(reason) {
        //         if (_that.status === PENDING) {
        //             _that.status = REJECTED;
        //             _that.reason = reason;
        //         }
        //     }
        // }
        // let p = new MyPromise((resolve, reject) => {
        //     reject('XKHM')
        // })
        // console.log(p);

        class MyPromise {
            static PENDING = 'pending';
            static FULFILLED = 'fulFilled';
            static REJECTED = 'rejected';
            constructor(executor) {
                this.status = MyPromise.PENDING;
                this.value = null;
                this.callback = [];
                try {
                    // 这个地方this.resolve只是拿到resolve方法，并不是this调用的
                    // 事实上是全局对象调用的，但是class里面默认是严格模式
                    // 如果不改变resolve的内部this指向，他的this是undefined
                    executor(this.resolve.bind(this), this.reject.bind(this));
                } catch (error) {
                    this.reject(error)
                }
            }
            resolve(value) {
                if (this.status === MyPromise.PENDING) {
                    this.status = MyPromise.FULFILLED;
                    this.value = value;
                    setTimeout(_ => {
                        this.callback.forEach(callFn => {
                            callFn.onFulfilled(value)
                        });
                    })
                }
            }
            reject(value) {
                if (this.status === MyPromise.PENDING) {
                    this.status = MyPromise.REJECTED;
                    this.value = value;
                    setTimeout(_ => {
                        this.callback.forEach(callFn => {
                            callFn.onRejected(value)
                        });
                    })
                }
            }
            then(onFulfilled, onRejected) {
                if (typeof onFulfilled !== 'function') {
                    onFulfilled = value => value;
                }
                if (typeof onRejected !== 'function') {
                    onRejected = value => value;
                }
                let promise = new MyPromise((resolve, reject) => {
                    if (this.status === MyPromise.PENDING) {
                        this.callback.push({
                            onFulfilled: value => {
                                this.parse(promise, onFulfilled(this.value), resolve, reject)
                            },
                            onRejected: value => {
                                this.parse(promise, onRejected(this.value), resolve, reject)
                            }
                        })
                    }
                    if (this.status === MyPromise.FULFILLED) {
                        setTimeout(() => {
                            this.parse(promise, onFulfilled(this.value), resolve, reject)
                        })
                    }
                    if (this.status === MyPromise.REJECTED) {
                        setTimeout(() => {
                            this.parse(promise, onRejected(this.value), resolve, reject)
                        })
                    }
                });
                return promise;
            }
            parse(promise, res, resolve, reject) {
                if (promise == res) {
                    throw new TypeError('then返回的promise不能是跟then相同的Promise');
                }
                try {
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject)
                    } else {
                        resolve(res)
                    }
                } catch (error) {
                    reject(error)
                }
            }
            static resolve(value) {
                return new MyPromise((resolve, reject) => {
                    if (value instanceof MyPromise) {
                        value.then(resolve, reject);
                    } else {
                        resolve(value);
                    }
                })
            }
            static reject(reason) {
                return new MyPromise((_, reject) => {
                    reject(reason);
                })
            }
            static all(promises) {
                let resolves = [];
                return new MyPromise((resolve, reject) => {
                    promises.forEach((promise, index) => {
                        promise.then(value => {
                            resolves.push(value)
                            if (resolves.length === promises.length) {
                                resolve(resolves);
                            }
                        }, reason => {
                            reject(reason);
                        })
                    })
                })
            }
            static race(promises) {
                return new MyPromise((resolve, reject) => {
                    promises.forEach(promise => {
                        promise.then(value => {
                            resolve(value)
                        })
                    })
                })
            }
        }
        let p1 = MyPromise.reject('XKHM1');
        let p2 = MyPromise.reject('XKHM2');
        let p3 = MyPromise.reject('XKHM3');
        let p4 = MyPromise.resolve('XKHM4');
        let p5 = new MyPromise(resolve => {
            setTimeout(_ => {
                resolve('XKHM10')
            }, 3000)
        })
        let p10 = MyPromise.race([p1, p5]).then(value => {
            console.log(value);
        }, reason => {
            console.log(reason);
        })
        console.log(p10);
        // MyPromise.reject('xkhm').then(null, reason => {
        //     console.log(reason);
        // })
        // 测试
        // let p = new MyPromise((resolve, reject) => {
        //     reject('XKHM');
        // });
        // console.log(p);
        // p.then(value => {
        //     console.log(value);
        //     return '掘金'
        // }, reason => {
        //     console.log(reason);
        // }).then(value => {
        //     console.log(158);
        // });
        // console.log('星空海绵');

        // let p1 = new MyPromise((resolve, reject) => {
        //     setTimeout(() => {
        //         resolve("后盾人");
        //     });
        // });
        // let p2 = p1.then(_ => p2)
    </script>
</body>

</html>