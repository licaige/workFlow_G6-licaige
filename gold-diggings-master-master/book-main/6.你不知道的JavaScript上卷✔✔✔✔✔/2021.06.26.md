## 第2章 this全面解析

>前行。

- 1.this绑定的4条规则：
  
>1.由new调用？绑定到新创建的对象。

>2.由call或者apply（或者bind）调用？绑定到指定对象。

>3.由上下文对象调用？绑定到那个上下文对象。

>4.默认：在严格模式下绑定到undefined，否则绑定到全局对象。

## 第3章 对象

>学习的目的，理解了解式学习，而不是死记硬背式学习。

- 1.JavaScript中的函数是“一等公民”，因为它们本质上和普通对象一样（只是可以调用），所以可以像操作其他对象一样操作函数（比如当作另一个函数的参数）。 --摘抄

- 2.null在使用typeof判断的时候显示为object类型的原因是：不同的对象在底层都表示为二进制，在JavaScript中二进制前三位都为0的话会被判断为object类型，null的二进制表示是全0，自然前三位也是0，所以执行typeof时会返回“object”。

- 3.深复制和浅复制。

- 4.Getter和Setter都会默认调用，在对象获取属性值和设置属性值的时候。

## 第4章 混合对象“类”

>尝试。

- 1.类的另一个核心概念是多态，这个概念是说父类的通用行为可以被子类用更特殊的行为重写。实际上，相对多态性允许我们从重写行为中引用基础行为。 --摘抄

- 2.类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类。我们之后会看到，在JavaScript代码中这样做会降低代码的可读性和健壮性。 --摘抄

- 3.子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。 --摘抄

- 4.子类得到的仅仅是继承自父类行为的一份副本。 --摘抄

- 5.类的继承其实就是复制。

- 6.多重继承意味着所有父类的定义都会被复制到子类中。 --摘抄

## 第5章 原型

>体验。

- 1.原型继承与原型链。

- 2.Object.create(...)方法带来的轻微性能损失（抛弃的对象需要进行垃圾回收），它实际上比ES6及其之后的方法更短而且可读性更高。 --摘抄

- 3.instanceof回答的问题是：在a的整条[[Prototype]]链中是否有Foo.prototype指向的对象？ --摘抄

- 4.对象之间的关系不是复制而是委托。 --摘抄

## 第6章 行为委托

>一往无前。

- 1.class仍然是通过[[Prototype]]机制实现的。 --摘抄

- 2.我们终于可以抛弃定义中的关键字function了，对所有JavaScript开发者来说真的是大快人心！ --摘抄

- 3.在软件架构中你可以选择是否使用类和继承设计模式。大多数开发者理所当然地认为类是唯一（合适）地代码组织方式，但是本章中我们看到了另一种更少见但是更强大地设计模式：行为委托。 --摘抄

- 4.行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。 --摘抄

- 5.JavaScript的原型链本质上就是行为委托机制。 --摘抄

- 6.当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。 --摘抄

- 总结：学习的目的是什么？这本你不知道的JavaScript上卷跟JavaScript高级程序设计是否有相同之处？

>学习的目的是掌握知识，并不是把书看完。

>是的，这本你不知道的JavaScript上卷跟JavaScript高级程序设计在原型和原型链相关章节有相同之处。
