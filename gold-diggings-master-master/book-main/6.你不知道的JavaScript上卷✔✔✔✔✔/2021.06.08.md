## 第1章 作用域是什么

>全面，通才。

- 1.ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 --摘抄

- 2.如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。赋值操作符会导致LHS查询。=操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 --摘抄

- 3.不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。 --摘抄

## 第2章 词法作用域

>追根朔源。

- 1.我们将作用域定义为一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 --摘抄

- 2.作用域共有两种主要的工作模型。 --摘抄

>词法作用域和动态作用域。

- 3.JavaScript采用的是词法作用域模型。

- 4.事实上，让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践。 --摘抄

- 5.没有任何函数可以部分地同时出现在两个父级函数中一样。 --摘抄

- 6.作用域查找会在找到第一个匹配地标识符时停止。 --摘抄

- 7.“遮蔽效应”，内部的标识符“遮蔽”了外部的标识符。 --摘抄

- 8.全局变量如果被遮蔽，可以使用window.a这种方式访问到。

- 9.无论函数在哪里被调用，也无论它如何调用，它的词法作用域都只由函数被声明式所处的位置决定。 --摘抄

- 10.欺骗词法作用域会导致性能下降。 --摘抄

- 11.可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。 --摘抄

- 12.eval用来执行代码其实做了一个欺骗词法作用域的操作。也就说eval会导致性能下降。

- 13.eval(...)通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。 --摘抄

- 14.但无论何种情况，eval(...)都可以在运行期修改书写期的词法作用域。 --摘抄

- 15.在严格模式的程序中，eval(...)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。 --摘抄

- 16.new Function(...) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化未动态生成的函数（前面的参数是这个新生成的函数的形参）。这种构建函数的语法比eval(...)略微安全一些，但也要尽量避免使用。 --摘抄

- 17.eval(...)取的是当前作用域，而new Function(...)始终取的都是全局作用域，所以从这个角度上来说，new Function(...)是比eval(...)要安全的。

- 18.在程序中动态生成代码的使用场景非常罕见，因为它带来的好处无法抵消性能上的损失。 --摘抄

- 19.eval(...)函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建一个全新的词法作用域。 --摘抄

- 总结：严格模式的作用是什么？作用域主要有哪2种工作模型？JavaScript采用的是哪种作用域模型？欺骗词法作用域的后果是什么？eval(...)和new Function(...)的区别？

>严格模式在某种程度上屏蔽了JS的一些hack操作。

>词法作用域和动态作用域。

>JavaScript采用的是词法作用域模型。

>欺骗词法作用域会导致性能下降。

>eval(...)的作用域为当前作用域，而new Function(...)的作用域为全局作用域（非严格模式下）。
