## 第5章：作用域闭包

>skill and simple-fun。

- 1.模块模式另一个简单但强大的用法是命名将要作为公共API返回的对象。 --摘抄

- 2.模块就是模块，即使在它们外层加上一个友好的包装工具也不会发生任何变化。 --摘抄

- 3.模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。 --摘抄

- 4.当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。 --摘抄

- 5.闭包也是一个非常强大的工具，可以用多种形式来实现模块等模式。 --摘抄

## 附录A 动态作用域

>在路上。

- 1.JavaScript中的作用域就是词法作用域（事实上大部分语言都是基于词法作用域的）。 --摘抄

- 2.实际上动态作用域是JavaScript另一个重要机制this的表亲。 --摘抄

- 3.词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段（假设你没有使用eval()或with）。 --摘抄

- 4.作用域链是基于调用栈的，而不是代码中的作用域嵌套。 --摘抄

- 5.事实上JavaScript并不具有动态作用域。它只有词法作用域，简单明了。 --摘抄

>注意词法作用域是在书写代码阶段就确定了作用域而不是运行阶段。

- 6.this机制某种程度上很像动态作用域。 --摘抄

- 7.词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。 --摘抄

>注意区分词法作用域和动态作用域是在何时确定的。并且词法作用域关注的是函数在何处声明，而动态作用域关注函数从何处调用。

- 8.this关注函数如何调用，这就表明了this机制和动态作用域之间的关系多么紧密。 --摘抄

## 附录B 块作用域的替代方案

>期望值决定最后的成果。

- 1.从ES3发布以来，JavaScript中就有了块作用域，而with和catch分句就是块作用域的两个小例子。 --摘抄

>在ES6之前可以通过try/catch来模拟let产生的块作用域。

- 2.catch分句具有块作用域，因此它可以在ES6之前的环境中作为块作用域的替代方案。 --摘抄

- 3.hack方案。

- 4.try/catch的性能的确很糟糕，但技术层面上没有合理的理由来说明try/catch必须这么慢，或者会一直慢下去。 --摘抄

>chrome对try/catch的性能做了优化，至少81版本及以后性能影响不大。

- 5.IIFE和try/catch并不是完全等价的，因为如果将一段代码中的任意一部分拿出来用函数进行包裹，会改变这段代码的含义，其中的this、return、break和continue都会发生变化。IIFE并不是一个普适的解决方案，它只适合在某些情况下进行手动操作。 --摘抄

## 附录C this词法

>顺其自然，相信自己。

- 1.ES6添加了一个特殊的语法形式用于函数声明，叫做箭头函数。 --摘抄

- 2.因此ES6的一个初衷就是帮助人们减少重复的场景，事实上包括修复某些习惯用法的问题，this就是其中一个。 --摘抄

- 3.箭头函数用当前的词法作用域覆盖了this本来的值。 --摘抄

- 4.本书之所以可以非常深入和完整地解释JavaScript，完全是因为牺牲了陪伴家人的时间。 --摘抄

>1万小时定律。

## 第2部分 this和对象原型

>在路上。

## 第1章 关于this

>船到桥头自然直。

>时间的车轮滚滚向前。

- 1.任何足够先进的技术都和魔法无异。 --摘抄

- 2.this提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将API设计得更加简洁并且易于复用。 --摘抄

- 3.函数可以自动引用合适得上下文对象有多重要。 --摘抄

- 4.每当你想要把this和词法作用域得查找混合使用时，一定要提醒自己，这是无法实现的。 --摘抄

- 5.this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 --摘抄

>注意：this是在运行时进行绑定的，而不是编写时绑定，不像词法作用域，在编写的时候就确定了，所以说this本质上其实是动态绑定的。

- 6.学习this的第一步是明白this既不指向函数自身也不指向函数的词法作用域，抛开以前错误的假设和理解。 --摘抄

>如同一张白纸，写东西是非常的迅速的，不像有字的纸，还要擦去以前的痕迹再写字。

- 7.this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 --摘抄

## 第2章 this全面解析

>学习是一个过程。

- 1.调用栈：call stack。

- 2.this的默认绑定注意区分严格模式和非严格模式。

- 3.区分直接调用者和间接调用者。

- 4.注意this调用时隐式丢失的问题。

- 5.通过call，apply，bind对this进行显示绑定。

- 6.实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。 --摘抄

- 总结：什么是闭包？JavaScript有没有动态作用域？我们需不需要学会使用this？

>当函数可以记住并访问所在的词法作用域，即函数在当前词法作用域之外执行，此时就产生了闭包。

>JavaScript没有动态作用域，只有词法作用域。

>我们需要学会使用this，这样能使我们写的代码更加的优雅，而this也是我们应该掌握的基础语法。
