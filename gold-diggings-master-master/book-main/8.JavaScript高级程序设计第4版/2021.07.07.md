## 第8章 对象、类与面向对象编程

>作研究就像一场长跑比赛，遇到了高手，被人家甩得很远，不能着急，不能乱了方寸，该怎么跑还是怎么跑。他后来总是告诉新来的研究院不要在意中途的快慢，最后胜出的人，才是真正的胜者。

- 1.这样重写之后，Person.prototype的constructor属性就不指向Person了。在创建函数时，也会创建它的prototype对象，同时会自动给这个原型的constructor属性赋值。而上面的写法完全重写了默认的prototype对象，因此其constructor属性也指向了完全不同的新对象（Object构造函数），不再指向原来的构造函数。虽然instanceOf操作符还能可靠地返回值，但我们不能再依靠constructor属性来识别类型了。 --摘抄 

```javascript
        // 原型模式优化
        function Person() { };
        Person.prototype = {
            name: 'Nicholas',
            age: 29,
            job: 'Software Engineer',
            sayName() {
                console.log(this.name);
            }
        }
```

- 2.因为从原型上搜索值得过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出来。 --摘抄

- 3.虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。 --摘抄

- 4.重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。 --摘抄

- 5.实例只有指向原型的指针，没有指向构造函数的指针。 --摘抄

- 6.重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。 --摘抄

- 7.原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。 --摘抄

>也就是说可以在原型上扩展和重写原型方法。

- 8.尽管可以这么做，但并不推荐在产品环境中修改原生对象原型。这样做很可能造成误会，而且可能引发命名冲突（比如一个名称在某个浏览器实现中不存在，在另一个实现中却存在）。另外还有可能意外重写原生的方法。推荐的做法是创建一个自定义的类，继承原生类型。 --摘抄

- 9.原型模式也不是没有问题。首先，它弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要的问题源自它的共享特性。 --摘抄

- 10.可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。 --摘抄

- 11.如果这是有意在多个实例间共享数组，那没什么问题。但一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。 --摘抄

- 12.很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方法，而这主要是通过原型链实现的。 --摘抄

>原型链的作用就体现在这，为了在JS中实现继承。

- 13.基本思想就是通过原型继承多个引用类型的属性和方法。 --摘抄

- 14.默认情况下，所有引用类型都继承自Object，这也是通过原型链实现的。 --摘抄

- 15.原型与实例的关系可以通过两种方式来确定。第一种方式是使用instanceOf操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceOf返回true。 --摘抄

- 16.确定这种关系的第二种方式是使用isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回true。 --摘抄

- 17.以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。 --摘抄

- 18.原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值得时候。 --摘抄

- 19.在使用原型实现继承时，原型实际上变成了另一个类型得实例。这意味着原先的实例属性摇身一变成为了原型属性。 --摘抄

- 20.原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。 --摘抄

- 21.为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”的技术在开发者设去流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：在子类构造函数中调用父类构造函数。 --摘抄

```javascript
        // 盗用构造函数
        function A() {
            this.friends = ['小明', '朵朵'];
        }
        function B() {
            A.call(this);
        }
        const a = new B();
```

- 22.盗用构造函数可以让每个实例有自己的属性。

- 23.盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题，必须在构造函数中定义方法，因此函数不能重用。 --摘抄

- 24.子类也不能访问父类原型上定义的方法。 --摘抄

- 25.组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中起来。基本的思路时使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性。 --摘抄

```javascript
        // 组合继承
        function A() {
            this.friends = ['小明', '朵朵'];
        }
        A.prototype.say = function () {
            console.log(12543);
        }
        function B() {
            A.call(this);
        }
        B.prototype = new A();
```

- 26.组合继承弥补了原型链和盗用构造函数的不足，是JavaScript中使用最多的继承方式。而且组合继承也保留了instanceOf操作符和isPrototypeOf()方法识别合成对象的能力。 --摘抄

- 27.即使不自定义类型也可以通过原型实现对象之间的信息共享。 --摘抄

```javascript
        // 原型式继承
        function object(o) {
            function F() { };
            F.prototype = o;
            return new F();
        }
```

>本质上，object()是对传入的对象执行了一次浅赋值。 --摘抄

>Object.create()方法本质上是原型式继承。

- 总结：实例原型和构造函数的关系？原型模式的问题？JS支持的继承类型是接口继承还是实现继承？Object.create()方法的本质是什么？

>实例和原型之间是通过构造函数联系的，可以用 实例._proto_ = 构造函数.prototype表示。

>原型模式的问题，共享特性。

>JS支持的继承类型是实现继承，因为JS的函数没有签名，所以JS的函数只支持实现继承，而实现继承是通过原型链实现的。

>Object.create()方法的本质是原型式继承。
