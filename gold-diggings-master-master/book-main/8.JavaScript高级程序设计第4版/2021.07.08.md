## 第4章 变量、作用域与内存

>撑死胆大的，饿死胆小的。

>勇敢。

- 1.由于没有规则定义变量必须包含什么数据类型，变量的值和数据类型在脚本生命期内可以改变。这样的变量很有意思，很强大，当然也有不少问题。 --摘抄

>产品思维：取舍，平衡。

- 2.原始值就是最简单的数据，引用值则是多个值构成的对象。 --摘抄

- 3.把一个值赋给变量时，JavaScript引擎必须确定这个值是原始值还是引用值。 --摘抄

- 4.保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。 --摘抄

- 5.引用值是保存在内存中的对象。 --摘抄

- 6.在操作对象时，实际上操作的时对该对象的引用而非实际对象本身。为此，保存引用值的变量是按引用访问的。 --摘抄

- 7.对于引用值而言，可以随时添加、修改和删除其属性和方法。 --摘抄

- 8.原始值不能有属性，尽管尝试给原始值添加属性不会报错。 --摘抄

- 9.原始值不能有属性，尽管尝试给原始值添加属性不会报错。 --摘抄

- 10.只有引用值可以动态添加后面可以使用的属性。 --摘抄

- 11.原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个Object类型的实例，但其行为类似原始值。 --摘抄

- 12.除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。 --摘抄

>原始值复制的时候复制体和本体是相互独立的。

- 13.在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。 --摘抄

>就是因为这一点，就出现了深拷贝和浅拷贝的问题。

>对象的数据是存在堆内存中的，指针是存在栈内存中的。

- 14.ECMAScript中所有函数的参数都是按值传递的。 --摘抄

- 15.变量有按值和按引用访问，而传参则只有按值传递。 --摘抄

- 16.这表明函数中参数的值改变之后，原始的引用仍然没变。当obj在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。 --摘抄

- 17.ECMAScript中函数的参数就是局部变量。 --摘抄

- 18.前一章提到的typeof操作符最适合用来判断一个变量是否为原始类型。更确切地说，它是判断一个变量是否为字符串、数值、布尔值或undefined的最好方式。如果值是对象或null，那么typeof返回“object”。 --摘抄

- 19.typeof虽然对原始值很有用，但它对引用值的用处不大。 --摘抄

- 20.我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript提供了instanceof操作符。 --摘抄

- 21.因此通过instanceof操作符检测任何引用值和Object构造函数都会返回true。类似地，如果用instanceof检测原始值，则始终返回false，因为原始值不是对象。 --摘抄

- 22.typeof操作符在用于检测函数时也会返回“function”。 --摘抄

- 23.变量或函数地上下文决定了它们可以访问哪些数据，以及它们地行为。每个上下文都有一个关联地变量对象，而这个上下文中定义地所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。 --摘抄

- 24.在浏览器中，全局上下文就是我们常说地window对象，因此所有通过var定义地全局变量和函数都会成为window对象的属性和方法。使用let和const的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。 --摘抄

- 25.全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器。 --摘抄

- 26.ECMAScript程序的执行流就是通过这个上下文栈进行控制的。 --摘抄

- 27.上下文中的代码在执行的时候，会创建变量对象的一个作用域链。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。 --摘抄

- 28.全局上下文的变量对象始终是作用域链的最后一个变量对象。 --摘抄

- 29.局部作用域中定义的变量可用于在局部上下文中替换全局变量。 --摘抄

- 30.内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。上下文之间的连接是线性的、有序的。 --摘抄

- 31.函数参数被认为是当前上下文中的变量，因此也跟上下文中的其他变量遵循相同的访问规则。 --摘抄

- 32.虽然执行上下文主要有全局上下文和函数上下文两种，但有其他方式来增强作用域链。 --摘抄

- 33.对with语句来说，会向作用域链前端添加指定对象；对catch语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。 --摘抄

- 总结：原始值和引用值分别是按照什么方式访问的？尝试给原始值添加属性会不会报错？原始值复制的时候本体和副本是不是相互独立的？对象的数据是存在堆内存中还是栈内存中？JS中所有的函数参数都是按值传递的吗？在浏览器中，全局上下文是否就等同于window对象？

>原始值是按照按值访问的，引用值是按照引用访问的。

>尝试给原始值添加属性不会报错，但是也获取不到，添加属性的值打印出来为undefined。

>是的，原始值复制的时候本体和副本是相互独立的。

>对象的数据是存在堆内存中，指针是存在栈内存中。

>JS中所有函数的参数都是按值传递的。

>是的，在浏览器中，全局上下文就等同于window对象。
