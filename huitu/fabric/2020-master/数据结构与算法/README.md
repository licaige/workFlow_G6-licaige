## 数组
- 两数求和问题：几乎所有的求和问题，都可以转化为求差问题
- 合并两个有序数组：双指针法
- 三数求和：先排序，然后遍历数组，每次固定其中一个数，在剩下的数中用对撞指针来寻找是否有两个数和这个固定数相加是等于0的
- 双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。所以一看到有序的数组就要联想到双指针
- 组合排序：总分相同，数学高的排前面，可以拼接成同一个字符串
- 滑动窗口和双指针一样都是暴力解法的优化
- 单调栈：通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素，且要求 O(n) 的时间复杂度

## 字符串
- 回文字符串：遍历前半部分，判断和后半部分是否对称（谨记对称性）
- 删除一个字符使之成为回文字符串：双指针 + 对称性，两边向中间遍历，遇到第一个不等的地方就尝试舍弃其中一个
- 词典存储：`let dic = { 单词长度: [单词数组] }`
- 类似 parseFloat 的功能：`let groups = str.match(/\s*([-\+]?[0-9]*).*/)`

## 链表（合并、反转、删除是重点）
- 涉及链表操作、尤其是涉及结点删除的题目（对前驱结点的存在性要求比较高），我都建议大家写代码的时候直接把 dummy 给用起来，不知道咋做先添加一个哨兵节点
- 处理链表的本质，是处理链表结点之间的指针关系
- 快慢指针和多指针
- 反转链表：`let pre = head; let cur = head.next;`，只反转一次，然后继续遍历
- 局部反转链表：还是要 pre 和 cur 两个标记，然后要缓存局部之外的两个节点 pre
- 环形链表：标记法和快慢指针

## 栈与队列
- 有效括号（栈的对称性）
- 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈
- 递减栈：通常是一维数组，要寻找任一元素右边（左边）第一个比自己大（小）的元素
- 用栈模拟队列：维护两个栈，第一个栈 push，第二个栈 pop
- dfs 和 bfs 除了递归，可以用栈来迭代实现

## 二叉树
- 二叉搜索树的中序遍历序列是有序的
- 平衡二叉树的出现，是为了降低二叉搜索树的查找时间复杂度，保持在 O(logN)
