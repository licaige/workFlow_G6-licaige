## Vite + TS 实现 2D 渲染引擎

- 第一步：编写应用入口 Application 类
- 第二步：添加定时器 Timer 类
- 第三步：封装常用绘制图形方法

### 坐标系
[0, 0]---------------------------> +x
|
|             -90°
|              |
|    ±180° ----|---- 0°
|              |
|              |
|             90°
|
|
↓
+y

### 3d 渲染过程
可以参考这篇文章：https://www.zhihu.com/question/22047061
虚拟3D物体的操作过程是有顺序的，是按照缩放->旋转->平移->投影的步骤来的。
为什么是缩放->旋转->平移->投影的步骤呢？还是拿小汽车为例。当小汽车从数据变成图形的时候，最开始是处于虚拟3D坐标系原点的，而且，初始的小汽车模型数据是优化过的，其中很多数据都是对称的或者干脆是0，也就说，最原始的小汽车数据是最容易处理的。这几个步骤中，平移是最简单的，缩放稍微复杂些，旋转是最复杂的了，而投影必须在最后一步。
如果不按这个顺序呢？也是可以操作的，只不过，会带来性能和效率上的问题。如果我们先平移后旋转，就相当于让简单的平移把最原始的优化数据破坏了，数据一旦被破坏就会变复杂，然后，这个“复杂化”的数据再进行旋转的话，会加大CPU的负荷。如果我们先旋转后平移，相当于最优的数据先进行复杂计算，然后再进行简单的平移计算，就能大大提高3D图形数据的处理速度了。
在3D游戏编程中，所有的3D物体都是由一个一个三角形组成的，而三角形是由3个小点组成的，也就是说，立方体的旋转过程，可以简化成一个又一个点的旋转。于是我们可以在2D坐标系下推导一下任意一点的旋转计算过程。
因为矩阵非常对称的关系，而且用在3D图形学中的矩阵都是正方形矩阵，计算机在处理矩阵乘法的时候有很多非常特别的方法，非常快速就能计算出结果。所以，用矩阵乘法来代替普通的乘法和加法，能大大提高3D图形处理的效率。
### 关于矩阵
可以参考这篇文章：https://www.zhihu.com/question/22047061
- 为什么矩阵会快？
    https://qastack.cn/software/312445/why-does-expressing-calculations-as-matrix-multiplications-make-them-faster
    https://www.zhihu.com/question/29162506
- 矩阵的最初的用途就是用来快速求解多元方程，当时被发明出来的时候很多人并不理解，一个快速计算方法有什么用？直到有了计算机，直到程序员在处理计算机3D问题时遇到了非常大困难的时候，计算机前辈才发现矩阵的真正用处——它能大大提高3D问题中复杂计算的效率。打个比方：在电脑上运行3D程序，就好比是在路上开车。而矩阵，就相当于是一个额外的氮气加速器。假设，在没有矩阵的情况下，车子只能开10码，那么，有了矩阵之后，车子就能开到200码的样子了。在程序员使用矩阵之前，他们也不知道计算机在处理矩阵的时候那么给力，这应该算是一个意外之喜吧。
- 如果没有矩阵的话，每一种基本的操作都会牵扯到巨量（看清楚，不是大量，是巨量）的数学计算。因为，任意的3D模型都是由最基本的三角形组成的，而一辆小汽车，可能有成百上千个三角形组成。拿最简单的平移操作来讲，要移动小汽车，实际上移动的是这成百上千的三角形！也就是说，每个三角形都需要进行一遍相同的数学加减乘除操作，这个计算量不用我说，你也应该知道很大。然而，如果把数学计算用矩阵代替的话，计算量就会骤减！因为，很多复杂的数学计算可以写在一个矩阵框框里面，然后，简单地用一个矩阵乘法，结果就出来了！
- 只有方矩阵才能求逆，项目中使用的都是方矩阵。但即使是方矩阵，也不是都能求逆
- I=M×M-1=M-1×M，矩阵M和它的逆矩阵M-1相乘的结果是一个单位矩阵，并且符合矩阵乘法的交换律（但是一般矩阵相乘不符合乘法交换律）。
- 矩阵乘积的逆等于每个矩阵的逆的相反顺序的乘积，例如，(A×B×C)-1=C-1×B-1 ×A-1，可以扩展到n个矩阵的情况下。
- 常用的方矩阵求逆算法有伴随矩阵算法和高斯消元算法，本项目中使用伴随矩阵方式求矩阵的逆。
- 如果要让矩阵作用在向量上，必须要让矩阵和向量相乘才能起作用。如果要让矩阵和向量相乘，则必须要将向量写成矩阵的形式。向量写成矩阵的形式，有两种选择：行向量形式：[x y ]。列向量形式。本项目中使用列向量的表现形式，矩阵 M 与列向量v 相乘的结果仍旧是个列向量。
- 我们一直在使用Canvas2D中的translate、scale和rotate方法。实际上，Canvas2D中这些方法都是在操作矩阵。
- 将包含平移的变换称为仿射变换，线性变换（缩放和旋转等）是仿射变换的特殊形式，即平移部分为0。我们要知道，只要使用了仿射变换及齐次坐标系后，就能使用矩阵乘法来统一操作图形的缩放、旋转和平移等变换。

### 优化策略
- 一般来说，60fps的帧率，如果每帧需要执行2000次以上，也就是十万次以上才考虑优化
- 当执行太多的函数调用后，你会发现性能变得很慢。每当我减少一些函数调用（把函数中的代码直接拷贝到当前调用位置），性能都会有提升。
    ```js
    // 如果在主循环中有如下代码
    // bad ❌
    matrix1.append(matrix2)

    // good ✅
    matrix1.a = matrix2.a * matrix1.a + matrix2.b * matrix1.c;
    // ...
    ```
- 减少作用域链的查询；多次访问对象属性（甚至循环调用），建议先把该属性保存到一个局部变量中，再使用
    ```js
    // bad ❌
    var array = [];
    function getName() {
        array[0] = 0;
        array[1] = 0;
        array[2] = 0;
        array[3] = 0;
        // ...
    }

    // good ✅
    var array = [];
    function getName() {
        var array = array;
        array[0] = 0;
        array[1] = 0;
        array[2] = 0;
        array[3] = 0;
        // ...
    }

    ```
- js的四则运算中，除法是最慢的，乘法其次。Math封装的数学函数中，sin与cos函数执行是最慢的。
    ```js 
    // a 在大部分情况下为0
    
    // bad ❌
    c = a * b;
    f = a * e;

    // good ✅
    if(a == 0) {
        c = 0;
        f = 0;
    } else {
        c = a * b;
        f = a * e;
    }
    ```
    尽量避免不必要的乘除运算，可能的情况下，缓存sin和cos运算结果。pixi.js中，显示对象的旋转要用到三角函数计算，引擎内部进行了标脏处理。egret中，对全局的三角函数计算方法进行了查表优化。

总结来看，这些所谓的性能优化点，大部分都是js语言在运行过程中的弱点，在其它语言中未必会重现。例如，上文提到的函数调用，在c++等语言中并不会对性能造成明显影响。
    
### 问答
- 怎么求点 p 在线段 AB 上的投影
    答：将 AB 转化为单位向量 ；计算 A点到 p 点的方向向量；pA 和单位向量的点积就是投影的长度，如果值为负就说明 p 在 A 点外，如果投影长度大于线段长度则说明 p 在 B 外。

- 求任给多边形的面积（多边形给出了每个定点坐标）
    答：先把所有的多边形分解成多个三角形，然后只要能求出三角形面积，问题就解决了。

- 三角形的面积
    答：向量叉乘的模长 / 2

- 如何判断一个三角形的顶点顺序

- 点在三角形内部
    答：面积法、内角和法、重心法、同侧法、同侧法扩展（向量两两相叉乘符号一致）。
    重心法：P = A +  u * (C – A) + v * (B - A) （u >= 0，v >= 0，u + v <= 1）
    同侧法：假设点P位于三角形内，会有这样一个规律，当我们沿着ABCA的方向在三条边上行走时，你会发现点P始终位于边AB，BC和CA的右侧。我们就利用这一点，但是如何判断一个点在线段的左侧还是右侧呢？我们可以从另一个角度来思考，当选定线段AB时，点C位于AB的右侧，同理选定BC时，点A位于BC的右侧，最后选定CA时，点B位于CA的右侧，所以当选择某一条边时，我们只需验证点P与该边所对的点在同一侧即可。

- 如何判断某两个点在某条直线的同一侧
    答：叉乘以及右手螺旋定则，叉乘结果符号相同则位于同一侧