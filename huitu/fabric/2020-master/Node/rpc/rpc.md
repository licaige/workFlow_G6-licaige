## 关于 rpc（远程过程调用、远程方法调用）
https://zhuanlan.zhihu.com/p/38012481
https://zhuanlan.zhihu.com/p/40606909

## 用前端的角度来理解
https://juejin.cn/post/6932683957066530830
和ajax相同点
- 总之都是两个设备之间到调用（ajax是浏览器到服务器、rpc是服务器到服务器）
- 需要双方约定一种数据格式

和ajax的不同
- ajax使用dns做为寻址服务到、rpc一般是在内网寻址
- ajax应用层使用http（html/json）、rpc通信到时候一般会使用二进制协议，性能优势
                                更小的数据包体积、更快的编码速度 rpc [0001 0000 1111 0101]
- rcp是基于tcp或udp协议通信

## 寻址
- ajax寻址过程是拿域名去dns进行解析，然后在发起真正请求
- rpc发起网络请求之前也是需要进行寻址到，因为不一定会使用ip进行请求，可能会使用id（l5，vip）之类的统一标识符，拿这个id去寻址服务器解析，然后通过返回的ip发起真正的请求


## rpc 是什么
rpc 的出现根本原因是因为单机到分布式的变迁
由于分布式，多台机子间就需要互相通信，rpc 就是分布式通信的一种方式，它是同步的（像 MQ 这种消息队列也是通信的一种，不过是异步的）

RPC 的协议分成两大类，一类是通讯层协议，另一类是应用层协议。通讯层协议一般是和业务无关的，它的职责是将业务数据打包后，安全、完整的传输给接受方，HSF、Dubbo、gRPC 这些都是属于通讯层协议。而应用层协议是约定业务数据和二进制串的转换规则，常见的应用层协议有 Hessian，Protobuf，JSON。这两种协议的关注点是不太一样的，对于一个 RPC 框架来说，通讯层协议一旦确定就很少变化，这要求它具备足够好的通用性和扩展性；而应用层协议理论上可以由业务自由选择，它更多的是关注编码的效率和跨语言等特性。在我看来
RPC 框架的核心是通讯层协议的设计。

## rpc 类别
RPC 首要解决的是通讯的问题，主流的 RPC 框架分为基于 HTTP 和基于 TCP 的两种。基于 HTTP 的 RPC 调用很简单，就和我们访问网页一样，只是它的返回结果更单一（JSON 或 XML）。它的优点在于实现简单，标准化和跨语言，比较适合对外提供 OpenAPI 的场景，而它的缺点是 HTTP 协议传输效率较低、短连接开销较大（HTTP 2.0 后有很大改进）。而基于 TCP 的 RPC 调用，由于 TCP 协议处于协议栈的下层，能够更加灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数。但是需要更多地关注底层复杂的细节，跨语言和跨平台难度大，实现的代价更高，它比较适合内部系统之间追求极致性能的场景。
目前流行的开源 RPC 框架有：阿里巴巴的 Dubbo、Facebook 的 Thrift、Google 的 gRPC、Twitter 的 Finagle 等。

## rpc 解决的问题
- 首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。
- 第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。
- 第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。
- 第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。
- 第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用


## rpc 做了什么
将复杂的协议编解码和数据传输封装到了一个函数中

假设远程某台机子上有以下几个服务
Class User
- getUser
- addUser
Class Order
- getOrder
- addOrder
... 其他类
- 其他方法

在其他机子上应该如何调用呢
const service = new Stub(User)
cosnt rs = service.getUser(id)
console.log(rs)

Stub 就是简版的 rpc，它屏蔽（封装）了底层细节，让开发者像调用函数方法一样调用远程服务。
那它封装了哪些底层细节呢？
- 链接网络
    let client = new net.Socket()
    client.connect(8888,'localhost')
- 传参：类名 > 方法名 > 参数
- 执行，远程服务给返回值


可优化的地方：
    1、序列化过程（不同的序列化方式体现在传输内容的多少、有没有兼容其他和压缩方式，如 xml、json、c++ struct、protobuffer、msgpack 等，xml 描述的信息就很多）
    2、传输协议的选择（不同的传输协议有不同的规范），也是基于 TCP 的上层协议

因为在 TCP 通道里传输的数据只能是二进制形式的，所以我们必须将数据结构或对象转换成二进制串传递给对方，这个过程就叫「序列化」。而相反，我们收到对方的二进制串后把它转换成数据结构或对象的过程叫「反序列化」。而序列化和反序列化的规则就叫「协议」。

============== 换种说法 ==============
1、本地调用某个函数方法
2、本地机器的RPC框架把这个调用信息封装起来（调用的函数、入参等），序列化(json、xml等)后，通过网络传输发送给远程服务器
3、远程服务器收到调用请求后，远程机器的RPC框架反序列化获得调用信息，并根据调用信息定位到实际要执行的方法，执行完这个方法后，序列化执行结果，通过网络传输把执行结果发送回本地机器
4、本地机器的RPC框架反序列化出执行结果，函数return这个结果

============== 换种说法 ==============
- 调用方（Client）通过本地的 RPC 代理（Proxy）调用相应的接口
- 本地代理将 RPC 的服务名，方法名和参数等等信息转换成一个标准的 RPC Request 对象交给 RPC 框架
- RPC 框架采用 RPC 协议（RPC Protocol）将 RPC Request 对象序列化成二进制形式，然后通过 TCP 通道传递给服务提供方 （Server）
- 服务端（Server）收到二进制数据后，将它反序列化成 RPC Request 对象
- 服务端（Server）根据 RPC Request 中的信息找到本地对应的方法，传入参数执行，得到结果，并将结果封装成 RPC Response 交给 RPC 框架
- RPC 框架通过 RPC 协议（RPC Protocol）将 RPC Response 对象序列化成二进制形式，然后通过 TCP 通道传递给服务调用方（Client）
- 调用方（Client）收到二进制数据后，将它反序列化成 RPC Response 对象，并且将结果通过本地代理（Proxy）返回给业务代码

## 序列化的区别
互联网早期的序列化协议主要有COM和CORBA。当前常用的序列化协议，包括XML、JSON、Thrift、Protobuf和Avro。
希望压缩和传输要快
比如要传输 key: val
json、xml 体积大
protobuffer 不用传 key，只传val，两边有映射表；msgpack 要传 key
传输数字的有点尤为明显，比如传输数字 1000000000，用字符串传输要 10 个字节；用 int 32 来表示的话只需要 4 个字节；
                              126，用字符串 3 个字节，用二进制只需要 1 个字节

https://juejin.cn/post/6950558346785062920 不错，可以看看
序列化最终的目的是为了对象可以跨平台存储、进行网络传输。而进行跨平台存储和网络传输的方式就是数据IO，数据IO支持的数据格式是字节数组（byte array）。序列化的目的就是将对象转换为字节数组已备跨平台存储和网络传输。
需要进行“跨平台存储”或“网络传输”的数据，都需要进行序列化。 本质上存储和网络传输都需要经过把一个对象状态保存成一种跨平台识别的字节格式，之后其他的平台才可以通过字节信息解析还原对象信息。

于是序列化协议就诞生了：
为了保证数据交换，该转换过程应该是可逆的，因为单方面的只把对象转成字节数组没有意义。此时就需要在基于一定的规则进行字节数组的转换。我们是没办法把对象的本来面目还原回来的，把对象转成字节数组的时候制定的规则就是序列化协议。


- 什么是对象序列化? 对象序列化是指将对象的状态转换为字符串（浅显易懂）
- 序列化(Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程（百科）

什么是序列化?
简单来说序列化就是把对象储存在某一地方(硬盘、网络)，也就是将对象的内容进行流化。
为什么要序列化?
方便于传输、存储(内存中的对象状态保存到一个文件中或者数据库中;套接字在网络上传送对象)。

序列化的形式：
1)二进制序列化器BinaryFormatter，主要将对象序列化成流的形式，用于数据存储
2)JSON序列化器，主要将对象序列化成字符串，用于数据传输
主要区别：
1)二进制序列化器需要向需要序列化的类应用[Serializable]特性，而Json序列化器不需要
2)二进制序列化器只能序列化字段，而不能序列化属性，也就是说当一个类中不显示定义字段，二进制序列化器是不起作用的，JSON序列化器没有这条规定。在二进制序列化器中，若某个字段不需要序列化，可向其应用[NonSerialized]特性，以节省网络传输的带宽以及减少序列化后文件大小
3)二进制序列化后得到的是一个二进制文件，而JSON序列化后得到的是JSON字符串。

如果序列化后的内容还是日后给自己用的，自然是二进制序列化较好
Soap、XML、json 序列化都是为了交换数据用的

`var obj = {x:1, y:2};`当这句代码运行时，对象obj的内容会存储在一块内存中，而obj本身存储的只是这块内存的地址的映射而已。简单的说，对象obj就是我们的程序在电脑通电时在内存中维护的一种东西，如果我们程序停止了或者电脑断电了，对象obj将不复存在。那么如何把对象obj的内容保存在磁盘上呢（也就是说在没电时继续保留着）？这时就需要把对象obj序列化，也就是说把obj的内容转换成一个字符串的形式，然后再保存在磁盘上。另外，我们又怎么通过HTTP协议把对象obj的内容发送到客户端呢？没错，还是需要先把对象obj序列化，然后客户端根据接收到的字符串再反序列化（也就是将字符串还原为对象）解析出相应的对象。


## 协议就是自定义包
。通常它由一个 Header 和一个 Payload（类似于 HTTP 的 Body）组成，合起来叫一个包（Packet）。之所有要有包，是因为二进制只完成 Stream 的传输，并不知道一次数据请求和响应的起始和结束，我们需要预先定义好包结构才能做解析。

Header 就是我们自定义的一些头部信息，不同实现包含不同数据，下面是基本的包含字段
    - 记录协议的版本信息
    - type 标记包的类型，属于 0请求 || 1响应
    - id 将请求和它对应的响应关联起来， 可用一个 Int32 类型（4 字节）自增的数字表示
    - Codec 编解码规则，由应用层决定，不同场景不一样
    - 4 个字节（Int32） 记录 Payload 部分的长度
    ...
    - timeout 超时时间
Payload 就是具体数据


## 编解码的过程
```js
// 编码
const payload = {
  service: 'com.alipay.nodejs.HelloService:1.0',
  methodName: 'plus',
  args: [ 1, 2 ],
};
const body = new Buffer(JSON.stringify(payload));

const header = new Buffer(10);
header[0] = 0;
header.writeInt32BE(1000, 1);
header[5] = 1; // codec => 1 代表是 JSON 序列化
header.writeInt32BE(body.length, 6);

const packet = Buffer.concat([ header, body ], 10 + body.length);



// 解码
const type = buf[0]; // => 0 (request)
const requestId = buf.readInt32BE(1); // => 1000
const codec = buf[5];
const bodyLength = buf.readInt32BE(6);

const body = buf.slice(10, 10 + bodyLength);
const payload = JSON.parse(body);
```

上面编码那段代码里，我为了序列化一个 RPC 请求创建了三个 Buffer 对象，一个 Header 一个 Body，最后把两部分拼接成一个完整的 Packet。从逻辑上讲这段代码很清晰，没毛病，但是 Buffer 的创建和拼接都是比较耗性能的，为了追求极致的性能，我们需要避免频繁的创建小 Buffer。优化的思路很简单，就是预先分配一块比较大的内存，再维护一个偏移量（offset）代表当前写入的位置，每次写入以后将写入的长度加到偏移量上，写完以后从开始位置到结束位置创建切片。

```js
const buf = Buffer.alloc(1024 * 1024); // 分配一块 1M 的内存
let offset = 0;

// 开始编码
offset = 0; // 重置偏移量
buf[0] = 0;
buf.writeInt32BE(1000, 1);
buf[5] = 1; // codec => 1 代表是 JSON 序列化
offset += 10;

const payload = {
  service: 'com.alipay.nodejs.HelloService:1.0',
  methodName: 'plus',
  args: [ 1, 2 ],
};
const bodyLength = buf.write(JSON.stringify(payload), offset);
buf.writeInt32BE(bodyLength, 6);
offset += bodyLength;
buf.slice(0, offset); // 返回
```


## 如何接收包
- 基于 data 事件版本
- 基于 readable 事件
- 基于流的版本


## 为什么要使用自定义 tcp 协议的 rpc 做后端进程通信
- http1.1协议报文头携带的信息过于臃肿，影响传输速度，譬如header头的信息基本不会被消费。（基于文本从而导致API传输内容过于庞大）
- 另外伴随这业务发展，用户数、业务负责度及系统架构日渐复杂，业务服务演进到微服务架构后，需要对微服务进行服务治理。“服务发现”，"负载均衡"，“熔断降级”一类面向服务的高级特性，就是rpc框架带来的优势。

## 应用
RPC 主要用于公司内部的服务调用，性能消耗低，传输效率高，实现复杂。
HTTP 主要用于对外的异构环境，浏览器接口调用，App 接口调用，第三方接口调用等。
RPC 使用场景(大型的网站，内部子系统较多、接口非常多的情况下适合使用 RPC)：
长链接。不必每次通信都要像 HTTP 一样去 3 次握手，减少了网络开销。
注册发布机制。RPC 框架一般都有注册中心，有丰富的监控管理;发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。
安全性，没有暴露资源操作。
微服务支持，就是最近流行的服务化架构、服务化治理，RPC 框架是一个强力的支撑。

## 补充
- 基于文本的协议显然会带来一些开销，因为它们需要发送更多的数据来传输相同数量的信息。
- 两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称为传输(transfer)。

其实真正网络传输的时候都是以二进制传输，之所以有基于文本的，那是因为我们可以把8个二进制一组拿来解析，然后对应到ASCII表，得到文本。其他的图片、图形、图像、音频、视频、文件等等收据，在网络传输前都会被编码成一个一个的字节，字节虽说也是8个二进制一组，但解析的时候，一般是多个字节算作一个基本单位，具体几个看编码方式。但如果强制映射到ASCII表，会得到一堆乱码。

基于文本的有：
1. 广泛应用于Web的HTTP协议，包括HTTP/1.0， HTTP/1.1
2. 用于邮件的SMTP协议
3. 用于语音信令传输的SIP、SDP协议
4. 用于域名、IP地址管理的DNS、DHCP协议
5. 用于远程命令传输的Telnet协议
6. 数据库底层是TCP，应用层也是基于文本的SQL语句

基于二进制（字节）的协议有：
1. HTTP协议的新版本，HTTP/2
2. 传输音视频的RTP协议
3. 传输文件的TFTP协议、FTP协议（数据传输是二进制，命令传输是文本）
4. 远程桌面的RDP协议

- TCP协议：分割HTTP数据，保证数据运输
TCP协议采用了三次握手的方式来保证数据的准确运输，在运输的数据的时候，发送标识过去给服务器，服务器也返回标识给客户端，而客户端收到消息后再次返回标识给服务器。这样一来就保证了数据运输是可靠的。

- IP协议：传输数据包，找到通信目的地地址。
IP协议把我们的产生的数据包发送给对方，IP地址指明了节点被分配的地址，但IP地址可能会变换，我们可以使用ARP协议来将IP地址反射为MAC地址。MAC地址是不会更改的，是网卡所属的固定地址。
在找到通信目的地之前，我们是需要不断的中转的，这过程我们称作为：“路由中转”，我们并不知道路由中转了多少次的。因此是不能全面了解到互联网中的传输状况的。

- HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。