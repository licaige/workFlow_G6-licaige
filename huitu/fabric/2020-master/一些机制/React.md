## Dan 的文章贼棒
https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/

- 每次渲染的状态 props、state、effects 都是独立的
- props和state在某个特定渲染中是不会改变的。
- 每次渲染都有它自己的 Effects
- 新的 UI -> 新的 effect
- 每一个组件内的函数（包括事件处理函数，effects，定时器或者API调用等等）会捕获某次渲染中定义的props和state。
- 在组件内什么时候去读取props或者state是无关紧要的。因为它们不会改变。在单次渲染的范围内，props和state始终保持不变。
- 当然，有时候你可能想在effect的回调函数里读取最新的值而不是捕获的值。最简单的实现方法是使用refs。
- React只会在浏览器绘制后运行effects。这使得你的应用更流畅因为大多数effects并不会阻塞屏幕的更新。Effect的清除同样被延迟了。上一次的effect会在重新渲染后被清除。
- React只会更新DOM真正发生改变的部分，而不是每次渲染都大动干戈。
- setCount(count + 1) 变成 setCount(c => c + 1)
- 举个例子，当你在Google Docs编辑文档的时候，Google并不会把整篇文章发送给服务器。那样做会非常低效。相反的，它只是把你的修改以一种形式发送给服务端。虽然我们effect的情况不尽相同，但可以应用类似的思想。只在effects中传递最小的信息会很有帮助。类似于setCount(c => c + 1)这样的更新形式比setCount(count + 1)传递了更少的信息，因为它不再被当前的count值“污染”。它只是表达了一种行为（“递增”）。
- 当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用useReducer去替换它们。实际上，在组件内定义的函数每一次渲染都在变。
- 函数每次渲染都会改变这个事实本身就是个问题。
- 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在effects中使用.
- 使用useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。
- 逻辑的复用：mixin -> hoc -> hook
- Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。
- 大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用Hook，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。
- 使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。
- 相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个函数比理解一个class更快。Hooks让你可以在classes之外使用更多React的新特性。


## fiber 的理解
- https://pomb.us/build-your-own-react/
- https://juejin.cn/post/6844903975112671239


## 为什么要有 Hooks
在 Hooks 出现之前，类组件和函数组件的分工一般是这样的：
- 类组件提供了完整的状态管理和生命周期控制，通常用来承接复杂的业务逻辑，被称为“聪明组件”
- 函数组件则是纯粹的从数据到视图的映射，对状态毫无感知，因此通常被称为“傻瓜组件”

那么 Hooks 的出现又是为了解决什么问题呢？我们可以试图总结一下类组件颇具代表性的痛点：

- 令人头疼的 this 管理，容易引入难以追踪的 Bug
- 生命周期的划分并不符合“内聚性”原则，例如 setInterval 和 clearInterval 这种具有强关联的逻辑被拆分在不同的生命周期方法中
- 组件复用（数据共享或功能复用）的困局，从早期的 Mixin，到高阶组件（HOC），再到 Render Props，始终没有一个清晰直观又便于维护的组件复用方案

没错，随着 Hooks 的推出，这些痛点都成为了历史！

