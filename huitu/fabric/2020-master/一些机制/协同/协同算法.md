## 协同算法 || OT 算法 || 在线编辑
## Intro
广义上的分布式系统的概念在1978年被Leslie Lamport提出；在后续的几十年间，科学家一直在为在分布式系统上提升一致性、时空占用与IO性能努力。直到21世纪初，由Google的几篇论文为标志，分布式系统进入成熟阶段。
协同编辑可以认为是分布式系统的一种特殊衍生，因此初期的协同编辑系统直接基于传统分布式系统实现。协同编辑问题可以抽象成存在多个同时编辑的leader，这些leader各自对原文档进行修改后再次进行数据同步，这时必然会导致冲突。传统的解决冲突的方法有如下三种：
- 锁。通过在系统中获取锁的方式，阻止其它leader编辑；
- 冲突合并。暴露冲突给用户，让用户决定怎么处理冲突；
- 串行。在系统中设定一个自增序号，只接受第一个争抢到序号的变动。
但是在实践中发现，传统分布式系统的冲突处理对强人机交互的在线协同编辑系统不友好，会导致编辑响应慢/数据丢失/操作成本上升。因此以1989年Ellis等人首次提出OT(Operation Transformation)的模型与算法为开端，在线协同编辑问题作为一个特化分支被从传统分布式系统中独立出来。
在线协同编辑作为一个特殊的分布式系统，与传统分布式系统的目标有很大的区别。在线协同编辑对整个分布式系统的响应速度和并行能力有更严苛的要求：响应速度代表着用户在进行输入交互时应当能尽快得到操作反馈，对整个系统的状态同步无感知；并行能力代表着多个用户共同进行操作以提高工作效率。
在这个设计目标的指导下，一条解决传统协同编辑路径中的反用户交互问题的道路被打开。在后续的十余年间，OT算法得到了大量的探索。OT算法的主要思想是本地产生的操作立刻执行, 接收到的远程操作需要与本地操作历史中已执行的并发操作进行操作转换后再执行. 与传统的锁机制和串行化方法相比,  OT算法的优势是具有很好的本地响应性. OT算法也面临一些技术挑战, 例如, 设计正确的操作转换函数困难, 不断有算法被找出特定协同场景下的“puzzle”; 大部分OT算法没有良好的伸缩性等。
到目前为止，从学界的角度看依旧没有一个逻辑上完美的OT算法，但是因为工业实践中可以通过设计绕过很多问题（指中心化），Google Docs/腾讯文档/飞书文档/WPS等基于OT的在线协同编辑系统被设计出来并经受了广泛使用的考验。
05年，地址空间转换算法（典型如AST）作为另一类支持操作意图一致性的协同编辑算法, 为共享对象的一致性维护提供了新的思路。与OT算法相比, 这类算法在处理远程操作时, 并不是通过修正操作来获取操作的正确执行位置, 而是通过计算文档的地址空间来将文档状态回退到操作产生时的状态来获取操作的执行位置。因为种种原因（我也不知道），这种算法只停留在了学界中，没有得到工业界的应用。
可交换的复制式的数据类型(CRDT)作为一类新的支持操作意图一致性的协同编辑算法被提出并得到了深入的研究。CRDT算法不需要保存操作历史，并发操作之间不需要进行操作转换。通过分配给所有操作对象唯一的标识符ID，使得并发操作之间可交换执行.大部分CRDT算法具有良好的伸缩性，适合应用于大规模的p2p协同编辑领域。CRDT算法也面临一些技术挑战，例如：如何设计并发操作的可交换执行、如何给操作对象分配全局唯一的ID，如何减少ID的空间开销等。
与OT算法对比，CRDT更年轻——这意味着不足与未来。CRDT需要更大的时空来运行，无法做到一些OT能做到的数据操作（如把数据从树的一部分移动到另一部分）；但CRDT在最新的学术实现中几乎追赶上了OT的性能，而在此同时CRDT比OT更便于接入与拓展，有更好的横向延展能力，并且为去中心化设计。即使是最流行的开源 OT 库 ShareDB 的作者Joseph也打算转投CRDT的方向。
## 传统协同编辑
### 悲观锁
锁的方案就是一个文档只能同时有一个用户在编辑。悲观锁在理想情况下简单粗暴，但是它几乎不协同。考虑到协同编辑的站点实际是在用户侧，无法确保站点间网络可信，在网络波动下锁会出现不释放/不通知的情况，导致用户无法获取锁进行编辑。
锁可以是文档级别的，也可以根据产品形态（比如页）细化，获得更好的协同效果。
场景ByTest，因为浏览器端无法稳定发出释放锁的信号，这个正在编辑的弹窗实际上是不准确的。
### 冲突合并
这个方案在于将变动间的冲突暴露给用户，由用户判断冲突双方并且选择最终保存的版本。
冲突合并的粒度可以做的很细，但是存在几个问题：
1. 无法自动进行合并，用户需要有合并冲突的能力。如果编辑方较多，合并将会出现的非常频繁
2. 产品形态展现合并冲突能力困难。纯文本与复杂应用的合并界面逻辑相差较大。
对于简单应用，合并也需要一定的专业知识。
对于复杂应用，无法将冲突粒度细化，也就意味着合并中会丢失更多的信息。
### 争抢
这个方案会给写入操作记录一个全局递增的的序号。在发生冲突的时候，选择第一个发出该序号的修改。比起前两种方案，这种方案能够完全自动化地处理冲突，也能够保证用户的写入一定是基于服务端版本。缺点就是在网络不稳定的情况下，序号的先后会被颠覆，大量的用户操作会在重新联网后丢失。
乐高编辑器目前就使用这种方案，造成了大批量的课件数据丢失的oncall（捂脸）
实时协同编辑
上述几个传统方案可以总结为锁机制和串行化。为了解决传统方案在实时系统中存在的响应时间长和忽略用户操作意图的问题，支持操作意图一致性的实时协同编辑算法成为研究的重点。这类算法的目的为在较高的网络延迟下也能够保证用户操作的高响应性、维护每个编辑者的操作意图、自动的冲突检测与合并。目前主要有OT和CRDT两种算法。
## 前置知识
一致性模型
一致性模型指导了协同编辑算法的设计与开发。
CC模型
1996年, Ressel明确阐述了协同编辑算法要满足两个一致性条件: 因果一致性(Causality Preservation)和结果一致性(Convergence), 并提出了CC模型。
- 因果一致性
  - 给定任意一对操作Oa和Ob, 如果Oa→Ob, 那么在所有站点Oa在Ob之前执行
  - 因果一致性令系统正常运行，并帮助用户维护关于协作期间正在发生的事情的逻辑思维模型。
- 结果一致性
  - 当一个协同会话在静默状态时, 所有站点共享文档的副本是一致的.
  - 因为网络环境的影响，系统不保证每时每刻的一致性，但保证最终的一致性。
CCI模型
后续研究发现CC模型不足以完整约束一个操作转换系统的行为. 因此,  Sun在CC模型的基础上进行了完善, 指出一个协同编辑系统除了要满足因果一致性和结果一致性外, 还需要做到操作意图一致性, 并给出OT算法应遵循的CCI模型: 因果一致性、结果一致性、操作意图一致性(Intention  Preservation). 大多数算法参照CCI模型设计和开发的. 
- 操作意图一致性
  - 要求在所有站点都保留操作的意图，而不管操作的执行顺序。
  - 所述的操作的意图 被定义为：远程站点的操作执行效果应该达到与本地站点生成操作时定义的效果相同的效果。
  - 操作意图一致性是协同编辑系统的重点，它由OT或CRDT等算法保证。
OT
OT 是一种支持协同计算功能和应用的技术。它于1989年被提出，2006年被应用到Google Docs，至今为止仍是实现在线协同编辑技术的最主要的技术选择。飞书文档等在线文档也都是基于OT构建的。
OT 算法的主要思想是本地产生的操作立刻执行, 接收到的远程操作需要与本地操作历史中已执行的并发操作进行操作转换后再执行（以保证系统的响应速度和一致性）
那么OT是怎么进行操作转换来避免并发的操作冲突呢？下面将介绍OT的几个基本思想。
一致性维护
两个站点对xabc这个字符串产生了两个操作：插入x和删除c。在OT的控制下，两个站点的本地先各自应用各自的操作，此时两个站点的字符串各自为xabc和ab。
当接受到远程操作时，远程操作将在应用到本地站点上之前进行转换。对于站点1，接受到的站点2的远程操作被转换成删除xabc的c；对于站点2，接受到的站点1的远程操作被转换成插入为xab。此时两个站点达到了最终结果一致，并且保持了双方的操作意图。
综上所述，OT一致性维护的基本思想是根据之前执行的并发操作的效果，将一个编辑操作转化为一种新的形式，使得转化后的操作保持原操作在原场景的操作意图，并保证最终的文档状态是一致的。
## undo & redo
1. 站点2执行O1=Insert[2,y]，传播到站点1后，双方状态同步为12y；
2. 站点1执行O2Insert[0,x]，传播到站点2后，双方状态同步为x12y
3. 此时，站点2发出撤销命令Undo(Insert[2,y])来撤销O1；此时OT会先创建一个O1的逆操作!O1=Remove[2,y]，然后改造!O1为T(!O1,O2)=Remove[3,y]，即O1的Undo为!O1变基到O2
此时Undo(O1)就能达到正确的UndoEffect，即消除本地操作O1的效果但是保留远端操作O2的效果。如果没有这个转化的动作，那么Undo(O1)就会成为Remove[2,y]，文档变为x1y，失去了用户的操作意图（撤销本地动作）。
综上所述，OT for undo 的基本思想是根据On之后执行的操作的效果，将On的逆操作转化，使转化后的逆操作能够实现正确的Undo效果。正确的撤消效果将消除O的效果，但保留其他操作的效果。  
## 数据结构
OT的数据结构是简单的线性地址（如纯文本），这也是复杂应用接入OT协同的最大障碍。然而，后续的研究表示，OT的适用性与应用数据结构能否在UI层面线性表示无关，而是取决于应用数据结构能否映射到一维的线性地址进行寻址。通过编写桥接层，OT能够支持复杂的数据对象。
比如富文本。
可以看出OT通过转换尝试解决CCI中的I，而CC怎么办呢？
对于因果一致性，一般采用上下文的设计，保证O只能应用在它被创建的Context上
对于结果一致性，工程中一般用中心化服务器来保证操作的全序
CRDT
CRDT是另一种支持协同计算功能和应用的技术。它是一种能够可以在网络中多个主机中并行地复制的一种数据结构，并且可以自动合并以及达到最终一致性。
CRDT分为两种：
- Operation-Based CRDT：将每一次对数据的操作通知给其他所有节点。只要节点知道了对数据的所有操作，就能合并到同一个状态。
- State-Based CRDT：将各个节点之间的CRDT数据直接进行合并，所有节点都能最终合并到同一个状态，数据合并的顺序不会影响到最终的结果。
CRDT会在创建操作意图时，通过不同的方法为操作对象分配唯一且全序的ID，通过ID将操作对象映射到响应结构中，得到操作对象的全序队列。通过编辑算法，所有站点执行完操作后，各站数据结构中保存的操作对象具有相同的全序位置。因此，CRDT数据类型最终会收敛到相同的最终状态。
这里的操作意图与上文CCI中的操作意图有区别；CRDT的操作意图不完全代表用户的操作意图。
全序ID映射
在CRDT系统中，为了生成唯一且全序的ID，需要两个ID：
- 唯一的站点ID
- Lamport timestamp 逻辑时间戳
站点ID很好理解，逻辑时间戳的生成也很简单：
localClock = localClock + 1
localClock = max(remoteClock, localClock) + 1
这两个ID的配合，就可以让CRDT生成分布式系统中唯一且全序的ID，来标定任意两个操作的先后顺序；即保证最终一致性。
墓碑
因为最终状态的收敛需要各站数据结构中保存所有的操作对象，所以就出现了一个很明确的问题：不能删除被删除的数据，因为会导致最终状态无法收敛，而不删除又会导致空间占用的无限增长。当然这个问题在后续的实现中被解决了——在确认不会被干涉后，放一个内容为空的墓碑对象。
可以看出CRDT通过为操作分配唯一且全序的ID映射的方法，解决了CCI中的CC，而I怎么办呢？
很可惜的是CRDT不是为了协同编辑场景专门设计的，当遇到编辑操作冲突时，操作意图的一致性需要针对文本进行额外的设计。当然社区有相关研究，但是目前没有成熟的生产使用。
## 对比
应用
- OT：Google Docs/腾讯文档/飞书文档... 几乎所有的成熟在线文档产品
- CRDT：Figma（一个剪枝的中心化CRDT）
区别
（前提是实际落地产品
OT
CRDT
中心化
允许去中心化
有成熟产品可以借鉴使用
依旧在迭代中，需要自主处理问题
更难保证一致性
更容易保证一致性
更容易保证意图一致
更难保证意图一致
空间占用小
空间占用大
更难接入，需要抽象操作与转换
更容易接入，理解成本低
Btw，在最新的学界论文中，CRDT的时空占用在理论上已经逼近OT，问题在于学界落地的时间和如何在协同编辑中保证意图一致性。
## Demo
OT
https://github.com/share/sharedb
CRDT
https://github.com/yjs/yjs
## Reference
https://www3.ntu.edu.sg/scse/staff/czsun/projects/otfaq/
http://cjc.ict.ac.cn/online/bfpub/hzf-2017317162523.pdf
https://www.cs.cityu.edu.hk/~jia/research/reduce98.pdf
https://zhuanlan.zhihu.com/p/452980520



## 在线文档中 Easysync2 算法介绍
https://slix.rocks/%E5%9C%A8%E7%BA%BF%E6%96%87%E6%A1%A3%E4%B8%AD-easysync2-%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/

https://juejin.cn/post/6983238501340823565


## google docs
 https://srijancse.medium.com/how-real-time-collaborative-editing-work-operational-transformation-ac4902d75682
