## 创建函数

* 开辟一个堆内存
* 把函数体中的代码当作字符串存储进去
* 把堆内存的地址赋值给变量名/函数名
* 函数在哪创建那么它执行的时候所需要查找的上级作用域就是谁

## 普通函数 fn 执行过程如下：

* 开辟全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个）
* 实参集合 `arguments = {}`，不管有没有形参，只要有传参数就有
* 形参赋值
* 变量提升
* 设置 this 指向
* 开始自上而下执行代码
* 遇到一个变量，先看是否是私有变量，否则向上级作用域中查找
* 有无 return，默认返回 undefined，等垃圾回收机制自动释放内存


## new fn() 函数执行过程如下：

* 和普通函数一样，开辟全新的执行上下文
* 实参集合 `arguments = {}`
* 形参赋值
* 变量提升
* v8 底层会默认创建一个对象实例（堆内存），形如 `let obj = {}`
* 让实例的 `__proto__` 指向 `fn.prototype`
* v8 底层会把上下文中的 this 指向这个对象，形如 `fn.call(obj)`
* 开始自上而下执行代码
* 如果 fn 函数自身有返回值 res 且不是基本类型，则返回 res，否则默认返回创建的实例 obj，但是要注意：构造函数中应尽量减少 return 的使用，防止覆盖实例


```js
// 普通函数和构造函数的例子
function fn(x) {
  let y = 100
  this.x = x
}
let res = fn(200)
console.log(res)
res = new fn(200)
console.log(res)
```
