## 一笔画手势识别

## 如何运行
- 在该目录下执行 npx vite 即可
- 具体操作（绘制手势-重新采样-平移-旋转-缩放-添加手势 || 绘制手势-自动-等待-添加手势）
- 比较（绘制手势-重新采样-平移-旋转-相似度比较 || 绘制手势-自动-等待-相似度比较）
- 自动 = (重新采样-平移-旋转-缩放)，注意顺序要一致，不然容易报错，毕竟没有写的很完善
## 思路
- 监听 canvas 鼠标事件，记录原始数据点 inputPoints（需要保留原始数据点）
- 对原始数据进行重新采样（因为原始数据点分布不均匀，鼠标移动的快慢对结果都会有影响）
- 获取新采样点的中心，平移至画布中心
- 对新采样点进行旋转，使之靠近某一个参考线（坐标系被八等分），目的是让所画的图形有一定的方向性，又不让至于太严格
- 对新采样点进行缩放，方便后续手势在同一个单元格内对比
- 计算手势的特征向量
- 保存手势，并绘制缩略图
- 重新按上述步骤绘制新图形，比较新图形与缩略图的余弦相似度，若误差小于某个阈值则匹配成功
- 记住我们的一笔画是有方向性的，如果同一个图形，顺时针和逆时针画是匹配补上的，需要反过来匹配一下
- 优化方向：准确度；容差能力（位置、大小、比例、形状、角度）；匹配时间；内存占用等

## 其他思路
- 网格识别（马赛克识别）
把用户绘制的图形和图形库里的图形放到同一张网格里面 ，然后逐个格子的去比较他们的相似度。核心思想类似于马赛克识别，例如比较两张照片是否相像的时候，先把两张照片马赛克化，然后去比较方块是否相像。
- 方向识别
比较用户绘制时，笔画的运行方向跟手势库中图形的方向是否一致。 比如在做矩形识别的时候，如果图形库中的矩形是先向右绘制，再向下绘制，再向左，再向上;用户绘制的图形也是先向右，再向下，再向左，再向上，那么我们可以认为用户所绘制的图形是一个矩形。
- $1算法（欧几里得相似度）
两个点A、B是否相似？判断依据为两个点之间的欧几里的得距离。“离的进，相似;离的远，不再相似”。规定一个距离S，两个点之间的欧几里得距离小于S，即为相似，否则，不相似。
- 量角器算法（余弦相似度）
两个点A、B是否相似？判断依据为两个点之间的夹角。“夹角小，相似;夹角大，不相似”。规定一个角度θ，两个点A、B与坐标原点O连线，变成两个矢量，判断它们的夹角，小于θ，即为相似，否则不相似。
- 余弦相似度与欧几里得相似度
余弦相似度在性能、容差能力上更可靠。而欧几里得相似度要求比较苛刻过于严格。余弦相似度更科学、合理、稳定，优于欧几里得相似度。

## 注意事项
1、绘制的方向性（顺时针、逆时针）
2、图形的宽高比（钝角、锐角、直角）
3、关键点的数量（合适的关键点数量）
和屏幕的大小、绘制的速率、绘制的密度、图形的复杂度等属性综合相关。
性能与关键点的数量有关。
4、复杂性（图形的复杂性）
是不是图形越复杂越难识别？是不是图形越简单越容易识别？
太简单的图形，由于特征不是很明显，所以经常会弄错，如圆和六边形或八边形，甚至三角形和圆形。
所以图形的识别率和图形的复杂性没有太大关系。主要的是特征，就是图形中的线条特征是否足够明显。




## 普遍思路
第一步：特征提取1. 手指按下时开始记录轨迹点，每划过一个新的点就记录到手势描述数组guesture中，直到手指离开屏幕。2. 将gesture数组里每个点的x,y坐标最大值与最小值求出中上下左右的边缘，求出该手势路径点的覆盖面积。3. 手势坐标归一化：以手势中心点为原点，将gesture里顶点归一化到-1<=x<=1, -1<=y<=1空间中。4. 数组长度归一化：将手势路径按照长度均匀划分成32段，用共32个新顶点替换guestue里的老顶点。

第二步：矢量归类 SVM，简单点的话算夹角（后面求归一化阀值的话，夹角比复杂度类似的 kNN好点）：1. 手势点乘：g1 * g2 = g1.x1*g2.x1 + g1.y1*g2.y1 + … + g1.x32*g2.x32 + g1.y32*g2.y322. 手势相似：相似度(g1, g2)=g1*g2/sqrt(g1*g1 + g2*g2)由此我们可以根据两个手势的相似度算成一个分数score。用户输入了一个手势g，我们回合手势样本中的所有样本g1-gn打一次相似度分数，然后求出相似度最大的那个样本gm并且该分数大于某个特定阀值（比如0.8），即可以判断用户输入g相似于手势样本 gm !

## 如何识别汉字
- 提取每个汉字的笔画特征，保存成一个字库;
- 通过手写板或者触摸板获取用户的手写轨迹坐标;
- 坐标预处理;
- 通过 KNN 算法，与字库中的每个汉字进行比较;
- 根据比较距离的大小进行排序，输出结果。
https://www.jianshu.com/p/e4c429c8fe97
丁:[[(93,198),(913,205)][(495,203)(470,847)(405,784)]]

笔画相似度算法之一：
Frechet Distance:首先找出曲线A到曲线B的最远点，然后计算该点到曲线B的最近距离，再反过来计算曲线B到曲线A的最短距离，取两个最短距离的最大值，作为两条曲线的相似度。

## 相似度算法
- https://www.zhihu.com/question/272195313/answer/2260755496
- https://www.zhihu.com/question/68251690/answer/338223062

## 图像识别
1.图像预处理，拍摄得图像灰度化，降噪，一般中值降噪用的多，如果是白纸黑字，中值效果会很更明显
2.二值化，然后用开运算，获得图像的连通域
3.图像分割，找到连通域并拟合外接多边形（矩形，圆都可以），把感兴趣图像分割出来（或者2,3合成一步，直接对灰度图阈值分割，再求连通域）
4.在原灰度图像上获得感兴趣区域后，进行特征提取（方法很多，这块是最难，也是对分类识别影响最大的地方）
5.对提取的特征进行清洗，降维也好，提取有效信息也好，这块直接影响分类识别的效率
6.需要的时候要进行归一化处理，减少量纲或者信息差别过大的影响
7.选择分类器，分类器很多常用的knn,svm,ann,td-tree，朴素贝叶斯等等，将数据处理好，使数据和标签一一对应，进行训练
8.多次训练，并在训练后对分类器参数优化（这一步搞不懂就不管，只要特征提取方法合理，默认参数一般也能达到个70％～80％）
9.对测试集进行识别因为数据量很大，图像识别其实就是数据挖掘，如何有效提取特征，是识别中比较重要的一块，当中为了提高提取的效果，可能还要进行图像仿射变换，图像细化等等。识别这玩意说简单很简单（多看看博客），说复杂很复杂（多看看论文）

## 注意点
- 距离度量随着空间的维度d的不断增加，计算量复杂也逐增，另外在高维空间下，在维度越高的情况下，任意样本之间的距离越趋于相等（样本间最大与最小欧氏距离之间的相对差距就趋近于0），也就是维度灾难的问题，如下式结论：
- 假设各样本有年龄，工资两个变量，计算欧氏距离（p=2）的时候，(年龄1-年龄2)² 的值要远小于(工资1-工资2)² ，这意味着在不使用特征缩放的情况下，距离会被工资变量（大的数值）主导, 特别当p越大，单一维度的差值对整体的影响就越大。因此，我们需要使用特征缩放来将全部的数值统一到一个量级上来解决此问题。基本的解决方法可以对数据进行“标准化”和“归一化”

## 用机器学习怎么实现
- 写的挺明了 https://jelly.jd.com/article/5f1502e8c3f8e00156bd3b3b

## 一笔画游戏
### 一笔画题目数据存储格式
- 点记法
```js
levels: [
    { // 当前关卡，必须是某一个解法才行
        name: "五角星", 
        coords: [
            {x: Ax, y: Ay}, 
            {x: Bx, y: By}, 
            {x: Cx, y: Cy}, 
            {x: Dx, y: Dy}, 
            {x: Ex, y: Ey}, 
            {x: Ax, y: Ay}
        ]
    },
    ...
]
```
- 线记法
```js
levels: [
    { // 当前关卡
        name: "五角星", 
        lines: [
            {x1: Ax, y1: Ay, x2: Bx, y2: By}, 
            {x1: Bx, y1: By, x2: Cx, y2: Cy}, 
            {x1: Cx, y1: Cy, x2: Dx, y2: Dy}, 
            {x1: Dx, y1: Dy, x2: Ex, y2: Ey}, 
            {x1: Ex, y1: Ey, x2: Ax, y2: Ay} 
        ]
    },
    ...
]
```

### 一笔画题目的录入
如何自动识别图像上的一笔（前提点线颜色不一致）：
1. 端点识别（获取像素数据，遍历识别点颜色）
2. 线段识别（将两个端点质检n等分（需要比端点直径小），n 等分点需要都是线的颜色）
3. 优化（先将原来大图数据缩小成小图再识别）

### 一笔画游戏通关解法
欧拉的一笔画原理。

- 奇顶点的个数要么是0，要么是2，才能一笔画出来！
- 走迷宫扶着墙走一定能走出去？其原理就是在图形中找到一个一笔画，