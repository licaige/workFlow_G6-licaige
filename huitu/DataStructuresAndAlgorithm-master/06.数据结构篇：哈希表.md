# 一、概述

哈希表是一种非常重要的数据结构。几乎所有的编程语言都有 **直接或者间接** 的应用这种数据结构。

哈希表通常是基于 **数组** 实现的，但是相对于数组，它也有很多的优势：

- 它可以提供非常快速的 **插入-删除-查找** 操作。
- 无论多少数据，插入和删除值需要接近常量的时间：即 $O(1)$ 的时间级，实际上，只需要 **几个机器指令** 即可完成。
- 哈希表的速度比 **树还要快**，基本可以瞬间查找到想要的元素。
- 哈希表相对于树来说编码要容易很多。

哈希表相对数组的一些不足：

- 哈希表中的数据是 **没有顺序** 的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。
- 通常情况下，哈希表中的key是 **不允许重复** 的，不能放置相同的key，用于保存不同的元素。

# 二、案例引入

**那么，哈希表到底是什么呢？**

哈希表不是特别容易理解，它不像数组和链表，甚至是树一样直接画出你就知道它的结构，甚至是原理了。

**哈希表的结构就是数组**，但是她神奇的地方在于对 **下标值的一种变换**，这种变换我们可以称之为 **哈希函数**，通过哈希函数可以获取到 **HashCode**。

不着急，我们慢慢来认识它到底什么？

接下来，我们通过三个案例，案例需要你挑选某种数据结构，而你会发现最好的选择就是哈希表：

- 案例一：公司使用一种数据结构来保存所有员工；
- 案例二：设计一个数据结构，保存联系人和电话；
- 案例三：使用一种数据结构存储单词信息，比如有50000个单词，找到单词后每个单词有自己的翻译、读音、应用等等。

---

**@案例一**

> **案例介绍：**

假如一家公司有1000个员工，现在我们需要将这些员工的信息使用某种数据结构保存起来，你会采用什么数据结构呢？

>  **方案分析：**

**方案1 --- 数组：**

一种方案是按照顺序将所有的员工依次存入一个长度为1000的数组中，每个员工的信息都保存在数组的某个位置上。但是我们要查看某个具体员工的信息怎么办呢？一个个找吗？不太好找。数组最大的优势是什么？通过下标值去获取信息。所以为了可以通过数组快速定位到某个员工，最好给员工信息中添加一个员工编号（工号），而编号对应的就是员工的下标值。当查找某个员工的信息时，通过员工编号可以快速定位到员工的信息位置。

**方案2 --- 链表：**

链表对应插入和删除数据有一定的优势，但是对于获取员工的信息，每次都必须从头遍历到尾，这种方式显然不是特别适合我们这里。

**最终方案：**

这样看，最终方案似乎就是数组了，但是数组还是有缺点，什么缺点呢？假如我想查看一下 张三这位员工的信息，但是我们不知道张三的员工编号，你怎么办呢？当然，你说我可以问他，但是你每查找一个员工都是问一下这个员工的编号么？不合适。线性查找？效率非常的低。能不能有一种办法，让 张三的名字和他的员工编号产生直接的关系呢？也就是说通过 张三 这个名字，我就能获取到他的索引值，而再通过索引值我就能获取到 张三 的信息呢？这样的方案已经存在了，其实就是使用 **哈希函数**，让某个key的信息和索引值对应起来。

---

**@案例二**

> **案例介绍：**

选择一个数据结构，保存联系人和电话。

> **方案分析：**

**方案1 --- 数组**

使用数组来存储联系人和电不是非常合适，因为如果需要查询某个联系人，就需要从数组中一个个取出数据和查询的联系人比较，效率非常的低。

**方案2 --- 链表**

链表和数组一样，效率非常低。

**方案3 --- 有没有一种方案，可以将联系人姓名和数组的下标值对应呢？**

那么我们就可以让联系人的名字作为下标值，来获取这个联系人对应的电话。但是联系人的名字（字符串）可以作为下标值么？当然不可以。所以你需要一种方案将字符串转成下标值，就是哈希函数。

---

**@案例三**

> **案例介绍：**

使用一种数据结构存储单词信息，比如有50000个单词，找到单词后每个单词有自己的翻译、读音、应用等等。

> **方案分析：**

**方案1 --- 数组**

这个案例更加明显能感受到数组的缺陷，我们拿到一个单词 JavaScript，我想知道这个单词的翻译/读音/应用，怎么可以从数组中查到这个单词的位置呢？线性查找？50000次比较？如果你使用数组来实现这个功能，效率会非常非常低，而且你一定没有学习过数据结构。

**方案2 --- 链表**

不需要考虑了吧？

**方案3 --- 有没有一种方案，可以将单词转成数组的下标值呢？**

如果单词转成数组的下标值，那么以后我们要查找某个单词的信息，直接按照下标值一步即可访问到想要的元素。

# 三、字母转数字（了解）

似乎所有的案例都指向了一个目标：**<u>将字符串转成下标值</u>**。但是，怎样才能将一个字符串转成数组的下标值呢？

**单词/字符串** 转 **下标值**，其实就是 **字母/文字** 转 **数字**。怎么转？

现在我们需要设计一种方案，可以将 **单词** 转成 **适当的下标**：

- 其实计算机中有 **很多的编码方案** 就是用数字代替单词的字符，就是 **<u>字符编码</u>**
- 比如 **ASCLL编码**：a是97，b是98，依次类推，122标识z。
- 我们也可以设计一个 **自己的编码系统**，比如 a是1，b是2，c是3，依次类推，z是26.
- 当然我们可以加上 **空格用0代替**，就是 **27个字符**（不考虑大写问题）
- 但是，有了编码系统后，一个单词如何转成数字呢？

> **方案一：数字相加**

一种转换单词的 **简单方案** 就是把单词的每个字符的编码求和，例如单词 **cats转成数字**：$3 + 1 + 20 + 19 = 43$​，那么43就作为cats单词的下标存在数组中。

**问题： **按照这种方案有一个很明显的问题就是 **很多单词** 最终的下标可能 **都是43**。

- 比如 was/tin/give/tend/moan/tick 等等。
- 我们知道数组中 **一个下标值** 位置 **只能存储一个数据**。
- 如果存入后来的数据，必然会造成 **数据的覆盖**。
- 一个下标存储这么多单词显然是 **不合理** 的。

> **方案二：幂的连乘**

现在，我们想通过一种算法，让 `cats` 转成数字后 **不那么普通**，**数字相加** 的方案就有些 **过于普通** 了。

有一种方案就是使用 **幂的连乘**，什么是幂的连乘呢？

其实我们平时用的 **大于10的数字**，可以用一种 **幂的连乘来表示它** 的唯一性，比如：
$$
7654 = 7 * 10^3 + 6 * 10^2 + 5 * 10 + 4
$$
我们的单词也可以使用这种方案来标识，比如 ：
$$
cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337
$$
这样得到的数字可以 **基本** 保证它的 **唯一性**，不会和别的单词重复。

**问题：**如果一个单词是 `zzzzzzzzzz`（一般英文单词不会超过10个字符），那么得到的数字超过 $7000000000000$，数组可以标识这么大的下标值么？

而且就算能够创建这么大的数组，事实上有很多是无效的单词，创建这么大的数组是没有意义的。

> **两种方案总结：**

- 第一种方案（把数字相加求和）产生的 **数组下标太少**。
- 第二种方案（与27的幂相乘求和）产生的 **数组下标又太多**。

# 四、认识哈希化

现在需要一种 **压缩方法**，把幂的连乘方案系统中得到的 **巨大整数范围** 压缩到 **可接受的数组范围** 中。

对于英文词典，多大的数组才合适呢？

- 如果只有50000个单词，可能会定义一个长度为50000的数组。
- 但是实际情况中，往往需要 **更大的空间** 来存储这些单词，因为我们不能保证单词会映射到每一个位置。
- 比如两倍的大小：100000

如何压缩呢？

- 现在，就找一种方法，把0到超过  $7000000000000$ 的范围，**压缩** 为从 0 到 100000.

- 有一种简单的方法就是使用 **<u>取余操作符</u>**，它的作用是得到一个数被另外一个数整除后的 **余数**。

取余操作的实现：

- 为了看到这个方法如何工作，我们先来看一个 **小点的数字范围** 压缩到一个 **小点的空间** 中。
- 假设把从 0 ~ 199 的数字使用 `largeNumber` 表示；压缩为从0到9的数字，使用 `smallRange` 表示。
- 下标值的结果：`index = largeNumber % smallRange;`
- 当一个数被10整除时，余数一定在 0~9 之间；
- 比如 `13 % 10 = 3; 157 % 10 = 7`
- 当然，这中间还是会有重复，不过重复的数量明现变小了，因为我们的数组是100000，而只有50000个单词。
- 就好比，你在 0~199 中间选取5个数字，放在这个长度为10的数组中，也会重复，但是重复的概率非常小（后面我们会讲到真的发生了重复应该怎么解决）

# 五、哈希表的一些概念 *

了解了前面关于哈希表的一些内容后，相信你应该懂了哈希表的原理了，我们来看看几个概念：

- **哈希化**：将 **大数字** 转化成 **数组范围内下标** 的过程，我们就称之为 **哈希化**；
- **哈希函数**：通常我们会将 **单词** 转成 **大数字**，**大数字** 在进行 **哈希化** 的代码实现放在一个函数中，这个函数我们就称为 **哈希函数**。
- **哈希表**：最终将数据插入到的这个 **数组**，对整个 **结构的封装**，我们就称之为是一个 **哈希表**。

但是，我们还有问题需要解决：

- 虽然，我们在一个100000的数组中，放50000个单词已经足够。
- 但是，通过哈希化后的下标值依然可能会 **重复**，如何解决这种重复的问题呢？

# 六、什么是冲突？*

尽管5000个单词，我们使用了100000个位置来存储，并且通过一种相对比较好的哈希函数来完成，但是依然 **可能会发生冲突**。

![](./IMGS/hash_insert.png)

比如 `melioration` 这个单词，通过哈希函数得到它数组下标值后，发现那个位置上已经存在一个单词 `demystify` ，因为它经过哈希化后和 `melioration` 得到的下标是相同的，这种情况我们就称为 **冲突**，虽然我们不希望这种情况发生，当然更希望每个下标对应一个数据项，但是通常这是不可能的。

冲突 **不可避免**，我们只能 **解决冲突**。

我们需要针对 **这种冲突** 提出一些 **解决方案**，即使冲突的 **可能性比较小**，你依然需要 **考虑到这种情况**，以便发生的时候进行对应的处理。

如何解决这种冲突呢？常见的情况又 **两种方案**：

- **链地址法**
- **开放地址法**

## 1. 链地址法

链地址法是一种比较常见的解决冲突的方案（也称为<u>拉链法</u>）。

其实，如果你已经理解了为什么产生冲突，看到下图后就可以立马理解链地址法的含义了。

![](.\IMGS\hash_link_address.png)

**图片解析：**

从图片中我们可以看出，链地址法解决冲突的办法是 **每个数组单元** 中存储的不再是 **单个数据**，而是一个链条。这个链条使用什么数据结构呢？常见的是 **数组或者链表**，比如是 **链表**，也就是每个数组单元中存储着一个链表，一旦发现重复，就将重复元素 **插入** 到链表的 **首位**，当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次寻找要查找的数据即可。

**数组还是链表呢？**

数组或者链表在这里其实都可以，**效率上也差不多**，因为根据哈希化的index找出这个数组或者链表时，通常就会使用 **线性查找**，这个时候数组和链表的效率差不多。当然在某些实现中，会将新插入的数据放在 **数组或者链表的最前面**，这种情况最好采用链表。因为数组在首位插入数据是需要所有其它项后移的，链表就没有这样的问题。

所以，具体使用数组还是链表？我觉得这个也得看 **业务需求**。

## 2. 开放地址法

开放地址法的主要工作方式是 **寻找空白的单元格** 来添加重复的数据。我们还是通过图片来了解开放地址法的工作方式：

![](.\IMGS\hash_open_link.png)

**图片解析：**

从图片的文字中我们就可以了解到，开放地址法其实就是要 **寻找空白的位置** 来放置冲突的数据项。

但是探索这个位置的方式不同，又三种方法：

- 线性探测
- 二次探测
- 再哈希法

### 2.1. 线性探测

线性探测非常好理解: **线性的查找空白的单元**。

插入的32:

- 经过哈希化得到的index=2，但是在插入的时候，发现该位置已经有了82，怎么办呢?
- 线性探测就是从 **index位置+1** 开始一点点查找 **合适的位置** 来放置32，什么是合适的位置呢?
- **空的位置就是合适的位置**，在我们上面的例子中就是index=3的位置，这个时候32就会放在该位置。

查询32呢？

- 查询32和插入32比较相似
- 首先经过哈希化得到index=2，比如2的位置结果和查询的数值是否相同，相同那么就直接返回。
- 不相同呢? 线性查找，从index位置+1开始查找和32一样的。
- 这里有一个特别需要注意的地方: 如果32的位置我们之前 **没有插入**，是否将整个哈希表查询一遍来确定32存不存在吗？
- 当然不是，查询过程有一个约定，就是查询到 **空位置，就停止**。
- 因为查询到这里有空位置，32之前不可能跳过空位置去其他的位置。

删除32呢？

- 删除操作和插入查询比较类似，但是也有一个 **特别注意点**
- 注意：删除操作一个数据项时，**不可以**将这个位置下标的内容**设置为null**，为什么呢？
- 因为将它设置为nul可能会**影响我们之后查询其他操作**，所以通常**删除一个位置的数据项**时，我们可以**将它进行特殊处理**（比如设置为-1）。
- 当我们之后看到-1位置的数据项时，就知道查询时要**继续查询**，但是插入时这个位置可以放置数据。

线性探测的问题：

- 线性探测有一个比较严重的问题，就是 **聚集**，什么是聚集呢？
- 比如我在没有任何数据的时候，插入的是 22-23-24-25-26，那么意味着下标值：2-3-4-5-6的位置都有元素。
- 这种**一连串填充单元**就叫做**聚集**。
- 聚集会影响哈希表的**性能**，无论是插入/查询/删除都会影响。
- 比如我们插入一个32，会发现**连续的单元**都**不允许**我们放置数据，并且在这个过程中我们需要探索多次。
- 二次探测可以解决一部分这个问题，我们一起来看一看。

### 2.2. 二次探测

我们刚才谈到，线性探测存在的问题:

- 如果之前的数据是**连续插入**的，那么新插入的一个数据可能需要**探测很长的距离**。

二次探测在线性探测的基础上进行了优化：

- 二次探测主要优化的是**探测时的步长**，什么意思呢?
- **线性探测**，我们可以看成是**步长为1**的探测，比如从下标值x开始，那么线性测试就是 $$x+1$$，$$x+2$$，$$x+3$$依次探测。
- **二次探测**，对步长做了优化（通过二次方函数来计算下一个槽位），比如从下标值x开始，$$x+1^2$$，$$x+2^2$$，$$x+3^2$$
- 这样就可以**一次性探测比较长的距离**，避免那些聚集带来的影响。

二次探测的问题：

- 但是二次探测依然存在问题，比如我们连续插入的是32-112-82-2-192，那么它们依次累加的时候步长是相同的。
- 也就是这种情况下会造成**步长不一的一种聚集**，还是会影响效率。(当然这种可能性相对于**连续的数字**会小一些）
- 怎么根本解决这个问题呢? 让**每个人的步长不一样**，一起来看看**再哈希法**吧。

### 2.3. 再哈希法

为了消除线性探测和二次探测中无论步长+1还是步长+平方中存在的问题，还有一种最常用的解决方案：**再哈希法**

再哈希法:

- 二次探测的算法产生的探测序列步长是固定的：1,4, 9,16，依次类推
- 现在需要一种方法：产生一种**依赖关键字的探测序列**，而不是每个关键字都一样
- 那么，**不同的关键字**即使映射到**相同的数组下标**，也可以使用**不同的探测序列**
- 再哈希法的做法就是：把关键字用另外一个哈希函数，**再做一次哈希化**，用这次哈希化的**结果作为步长**。
- 对于指定的关键字，步长在整个探测中是**不变**的，不过**不同的关键字**使用**不同的步长**。

第二次哈希化需要具备如下特点:

- 和**第一个哈希函数不同**。（*不要再使用上一次的哈希函数了，不然结果还是原来的位置*）
- **不能输出为0**。（*否则，将没有步长，每次探测都是原地踏步，算法就进入了死循环*）

其实，我们不用费脑细胞来设计了，计算机专家已经设计出一种工作很好的哈希函数:

- $$stepSize = constant - (key \;\%\; constant)$$
- 其中 $$constant$$ 是质数，且小于数组的容量。
- 例如：$$stepSize = 5 - (key \;\%\; 5)$$，满足需求，并且结果不可能为0.

# 七、哈希化的效率

哈希表中执行<u>插入</u>和<u>搜索</u>操作效率是非常高的：

- 如果 **没有产生冲突**，那么效率会更高。
- 如果 **发生冲突**，存取时间就依赖于后来的探测长度。
- 平均探测长度以及平均存取时间，取决于 **<u>装填因子</u>**，随着装填因子变大，探测长度也越来越多。
- 随着装填因子变大，效率下降的情况，在不同开放地址法方案中比链地址法更严重，所以我们来对比一下他们的效率，再决定我们选取的方案。

在分析效率之前，我们先了解一个概念：**<u>装填因子</u>**

- 装填因子表示当前哈希表中已经 <u>包含的数据项</u> 和 <u>整个哈希表长度</u> 的 <u>比值</u>。
- **<u>装填因子 = 总数据项 / 哈比表长度</u>**
- **<u>开放地址法</u> 的装填因子** 最大是多少呢？`1` ，因为它必须寻找到空白的单元才能将元素放入。
- **<u>链地址法</u> 的装填因子** 呢？**可以大于1**，因为拉链法可以无限的延伸下去，只要你愿意（当然后面效率就变低了）。

观察下图，分析效率：

![](.\IMGS\per_1.jpg)![](.\IMGS\per_2.jpg)![](.\IMGS\per_3.png)

由上图可以得出结论：在开发中实现哈希表的时候，我们更多会选择 **<u>链地址法</u>**。

# 八、优秀的哈希函数

讲了很久的**哈希表理论**知识，你有没有发现在整个过程中，一个非常重要的东西：**哈希函数**呢?

好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率。

- 哈希表的主要**优点是它的速度**，所以在速度上不能满足，那么就达不到设计的目的了。
- 提高速度的一个办法就是尽可能 **减少哈希函数中的乘法和除法**（*霍纳法则*），因为它们的性能是比较低的。

设计好的哈希函数应该具备哪些优点呢？

- 快速的计算
  - 哈希表的优势就在于效率，所以快速获取到对应的`hashCode`非常重要。
  - 我们需要通过快速的计算来获取到元素对应的`hashCode`。
- 均匀的分布
  - 哈希表中，无论是链地址法还是开放地址法，当多个元素映射到同一个位置的时候，都会影响效率。
  - 所以，优秀的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀的分布。

**快速计算：霍纳法则**

在前面，我们计算哈希值的时候使用的方式：$$cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337$$

这种方式是 **直观的计算结果**，那么这种计算方式会进行 **几次乘法几次加法** 呢？

- 当然，我们可能不止4项，可能有更多项；
- 我们抽象一下，这个表达式其实是一个多项式：
- $$a(n)x^2 + a(n-1)x^{(n-1)} +...+ a(1)x + a(0)$$

现在问题变成了多项式 **有多少次乘法和加法**：

- 乘法次数：$n + (n - 1) + ... + 1 = n(n + 1) / 2$
- 加法次数：$n$ 次
- $O(n^2)$

多项式的优化：**<u>霍纳法则</u>**

- 解决这类求值问题的高效算法 —— <u>霍纳法则</u>。在中国，霍纳法则也被称为 **<u>秦九韶算法</u>**。

通过如下变换我们可以得到一种 **快得多** 的算法，即：

- $Pn(x) = anx^n +a(n - 1)x^{(n - 1)} + ... + a1x + a0 = $ 
- $$((...(((anx + an - 1)x + an - 2)x + an - 3) ... ) x + a1) x + a0$$
- 这种求值的方案我们称为：<u>霍纳法则</u>

我们通过一个例子来看一下提取过程：$2n^3 + 5n^2 + n + 6$ -> $(2n + 5)n^2 + n + 6$ -> $((2n + 5)n + 1)n + 6$

- $P(n) = 2n^3 + 5n^2 + n + 6$
- $(2n + 5)n^2 + n + 6$
- $((2n + 5)n + 1)n + 6$

变换后，我们需要 **多少次乘法，多少次加法** 呢？

- 乘法次数：$n$ 次
- 加法次数：$n$ 次

如果使用大O表示时间复杂度的话，我们直接从 $O(n^2)$ 降到了 $O(n)$。

**# 均匀的分布**

在设计哈希表时，我们已经有办法处理 **映射到相同下标值** 的情况：**<u>链地址法</u>** 或者 **<u>开放地址法</u>**。

但是无论哪种方案，为了提高效率，最好的情况还是让数据在哈希表中 **均匀分布**。

因此，我们需要在 **使用常量的地方**，尽量使用 **质数**。

那些地方我们会使用到常量呢？

- 哈希表的长度
- 幂的乘积的底数（我们之前使用的是27）

# 九、哈希表实现 *

我们这里采用 **链地址法** 来实现哈希表：

- 实现的哈希表（基于storage的数组）每个下标（index）对应的是一个数组（bucket）（*当然也可以基于链表实现*）
- bucket中存放什么呢？我们最好将key和value都放进去，我们继续使用一个数组
- 最总我们的哈希表的数据格式是这样的：[[[k, v], [k, v], [k, v]], [[k, v], [k, v], [k, v]]]

## 1. 哈希函数

```js

export class HashTable {
  constructor() {
    this.storage = []; // 作为数组，存放元素
    this.count = 0; // 用于记录HashTable存放的数量
    this.limit = 7; // 表示数组当前的常数
  }
  /**
   * 哈希函数
   * 1. 将字符串转换成比较大的数字：hashCode
   * 2. 将数字大的hashCode压缩到数组范围（大小）之内
   * @param {*} str 字符串
   * @param {*} size 数组大小
   * @returns 下标
   */
  hashFunc(str, size) {
    // 1. 定义hashCode
    let hashCode = 0;
    // 2. 霍纳算法：计算hashCode的值
    for (let i = 0; i < str.length; i++) {
      hashCode = 37 * hashCode + str.charCodeAt(i);
    }
    // 3. 取余操作压缩到数组的（大小）范围内
    const index = hashCode % size;
    return index;
  }
}

```

## 2. 插入和修改

哈希表的插入和修改操作是同一个函数：

- 因为，当使用者传入一个<Key, Value>时
- 如果原来不存在该key，那么就是插入操作。
- 如果已经存在该key，那么就是修改操作。

代码解析:

- 步骤1：根据key获取对应的hashCode，也就是数组的索引值（index）

- 步聚2：根据index取出bucket
- 步骤3：判断bucket是否存在，如果不存在，则新建一个桶（空数组）

- 步骤4：线性查找，判断是否是修改数据
  - 遍历bucket，判断key是否等于传入的key，如果等于，则表示修改数据。

- 步骤5：如果不是修改操作，那么插入新的数据
  - 在bucket中push新的 [key, value] 即可.
  - 注意：这里需要将count + 1，因为数据增加了一项。

```js
/**
 * 插入/修改元素：HashMap -> { key, value }
 * @param {*} key
 * @param {*} value
 */
put(key, value) {
  // 1. 根据key获取对应的index
  const index = this.hashFunc(key, this.limit);
  // 2. 根据index获取对应的bucket
  let bucket = this.storage[index];
  // 3. 判断bucket是否存在，如果不存在则创建bucket（为了低耦合，这里直接用数组）
  if (!bucket) {
    bucket = [];
    this.storage[index] = bucket;
  }
  // 4. 判断是否是修改数据
  for (let i = 0; i < bucket.length; i++) {
    const [k] = bucket[i];
    // 修改
    if (k === key) {
      bucket[i][1] = value;
      return;
    }
  }
  // 5. 进行添加操作
  bucket.push([key, value]);
  this.count++;
  // 6. 扩容
  if (this.count > this.limit * MAX_LOAD_FACTOR) {
    let newLimit = this.limit * 2;
    newLimit = this.getPrime(newLimit);
    this.resize(newLimit);
  }
}
```

## 3. 获取元素

思路：

1. 根据key获取到对应的index
2. 根据index获取对应的bucket
3. 判断bucket是否存在，如果不存在，直接返回null
4. 线性查找bucket中每一个key是否等于传入key
   - 如果等于，那么直接返回对应的value
5. 遍历完后，依然没有找到对应的key
   - 直接返回null即可

```js
/**
 * 获取元素
 * @param {*} key
 */
get(key) {
  // 1. 根据key获取index
  const index = this.hashFunc(key, this.limit);
  // 2. 根据index获取bucket
  const bucket = this.storage[index];
  // 3. 判断bucket是否存在
  if (!bucket) {
    return null;
  }
  // 4. 有bucket，那么就进行线性查找
  for (let i = 0; i < bucket.length; i++) {
    const [k, v] = bucket[i];
    if (k === key) {
      return v;
    }
  }
  // 5. 依然没找到，那么返回null
  return null;
}
```

## 4. 删除元素

思路：

1. 根据key获取到对应的index
2. 根据index获取对应的bucket
3. 判断bucket是否存在，如果不存在，那么直接返回null
4. 线性查找bucket，寻找对应的数据，并且删除
5. 依然没有找到，那么返回null

```js
/**
 * 删除元素
 * @param {*}} key
 */
remove(key) {
  // 1. 根据key获取index
  const index = this.hashFunc(key, this.limit);
  // 2. 根据index获取bucket
  const bucket = this.storage[index];
  // 3. 判断bucket是否存在
  if (!bucket) {
    return null;
  }
  // 4. 线性查找，删除元素并将其返回
  for (let i = 0; i < bucket.length; i++) {
    const [k, v] = bucket[i];
    if (k === key) {
      bucket.splice(i, 1);
      this.count--;
      return v;
    }
  }
  // 5. 依然没找到，那么返回null
  return null;
}
```

## 5. 其他方法

```js
/**
 * 是否为空
 * @returns
 */
isEmpty() {
  return this.count === 0;
}
/**
 * 长度
 * @returns
 */
size() {
  return this.count;
}
```

## 6. 扩容

**为什么需要扩容？**

- 目前，我们是将所有的数据项放在 **长度为7的数组** 中的。
- 因为我们使用的是：**<u>链地址法</u>**，`loadFactor（装填因子）` 可能大于1，所以这个哈希表可以无限制的插入新数据。
- 但是，随着 **数据量的增多**，每一个 `index` 对用的 `bucket` 会越来越长，也就造成 **效率的降低**。
- 所以，在合适的情况对数组进行 **扩容**，比如扩容两倍。

**如何进行扩容？**

- 扩容可以简单的将容量 **增大两倍**（不是质数么？质数的问题后面再讨论）
- 但是这种情况下，所有的数据项 **一定要同时进行修改** （重新调用哈希函数，来获取到不同的位置）
- 比如 `hashCode = 12` 的数据项，在 `length = 8` 的时候，`index = 4`，在长度为16的时候呢？`index = 12`
- 这是一个 **耗时的过程**，但是如果 **数组需要扩容**， 那么这个过程是 **必要的**。

**什么情况下扩容呢？**

- 比较常见的情况是 `loadFactor > 0.75` 的时候进行扩容。
- 比如Java的哈希表就是在装填因子大于 0.75 的时候，对哈希表进行扩容。

**实现扩容**

当我们在不停的存取元素的时候，我们需要扩容，同样的，当我们再删除元素的时候，太大空间会造成不必要的内存消耗，所以我们也需要在适当的情况减少容量。接下来我们封装一个方法 `resize` 调整容量。

```js
/**
 * 哈希表扩容/降容
 * @param {*} newLimit
 */
resize(newLimit) {
  // 1. 保存旧的数组内容
  const oldStorage = this.storage;
  // 2. 重置属性
  this.storage = [];
  this.count = 0;
  this.limit = newLimit;
  // 3. 遍历oldStorage中所有的bucket
  oldStorage.forEach((bucket) => {
    // 3.1. 判断bucket是否存在
    if (!bucket) {
      return;
    }
    // 3.2. 重新插入
    for (let i = 0; i < bucket.length; i++) {
      const [k, v] = bucket[i];
      this.put(k, v);
    }
  });
}
```

然后在添加成功之后判断装填因子**<u>大于0.75</u>**时进行扩容

```js
if (this.count > this.limit * 0.75) {
	this.resize(this.limit * 2);
}
```

并且在删除成功之后判断装填因子**<u>小于0.25</u>**时减少容量

```js
if (this.limit > 8 && this.count < this.limit * 0.25) {
  this.resize(Math.floor(this.limit / 2));
}
```

## 7. 容量质数

我们前面提到过，容量最好是质数：

- 虽然在链地址法中将容量设置为质数，没有在开放地址法中重要。
- 但是其实链地址法中质数作为容量也更利于数据的均匀分布，所以，我们还是完成一下这个步骤。

我们这里先讨论一个常见的面试题，<u>判断一个数是质数</u>

首先你需要了解质数的特点：

- 质数也称为 **素数**。
- 质数表示大于1的自然数中，**<u>只能被1和自己整除的数</u>**

OK，了解了这个特点，应该不难写出他的算法：

```js
/**
 * 质数判断
 * @param {*} n
 * @returns
 */
isPrime(n) {
  // 如果输入值小于等于1，则不是质数；
  if (num <= 1) {
    return false;
  }
  // 如果输入值等于2，则是质数；
  if (num === 2) {
    return true;
  }

  // 如果输入值是偶数，则不是质数
  if (num % 2 === 0) {
    return false;
  }

  // 对于奇数，只需要遍历到其平方根即可，因为一个数的因子不可能大于其平方根
  const sqrt = Math.sqrt(num);
  for (let i = 3; i <= sqrt; i += 2) {
    // 判断是否能整除，如果能整除则不是质数
    if (num % i === 0) {
      return false;
    }
  }
  // 如果遍历结束都没有找到能整除的数
  return true;
}
```

## 8. 完整代码

```js
// -- 装填因子
const MAX_LOAD_FACTOR = 0.75;
const MIN_LOAD_FACTOR = 0.25;

export class HashTable {
  constructor() {
    this.storage = []; // 作为数组，存放元素
    this.count = 0; // 用于记录HashTable存放的数量
    this.limit = 7; // 表示数组当前的总长度
  }
  /**
   * 哈希函数
   * 1. 将字符串转换成比较大的数字：hashCode
   * 2. 将数字大的hashCode压缩到数组范围（大小）之内
   * @param {*} str 字符串
   * @param {*} size 数组大小
   * @returns 下标
   */
  hashFunc(str, size) {
    // 1. 定义hashCode
    let hashCode = 0;
    // 2. 霍纳算法：计算hashCode的值
    for (let i = 0; i < str.length; i++) {
      hashCode = 37 * hashCode + str.charCodeAt(i);
    }
    // 3. 取余操作压缩到数组的（大小）范围内
    const index = hashCode % size;
    return index;
  }
  /**
   * 质数判断
   * @param {*} n
   * @returns
   */
  isPrime(n) {
    // 如果输入值小于等于1，则不是质数；
    if (n <= 1) {
      return false;
    }
    // 如果输入值等于2，则是质数；
    if (n === 2) {
      return true;
    }

    // 如果输入值是偶数，则不是质数
    if (n % 2 === 0) {
      return false;
    }

    // 对于奇数，只需要遍历到其平方根即可，因为一个数的因子不可能大于其平方根
    const sqrt = Math.sqrt(n);
    for (let i = 3; i <= sqrt; i += 2) {
      // 判断是否能整除，如果能整除则不是质数
      if (n % i === 0) {
        return false;
      }
    }
    // 如果遍历结束都没有找到能整除的数
    return true;
  }
  /**
   * 获取质数
   * @param {*} n
   * @returns
   */
  getPrime(n) {
    while (!this.isPrime(n)) {
      // 14 → 17
      // 34 → 37
      n++;
    }
    return n;
  }
  /**
   * 哈希表扩容/降容
   * @param {*} newLimit
   */
  resize(newLimit) {
    // 1. 保存旧的数组内容
    const oldStorage = this.storage;
    // 2. 重置属性
    this.storage = [];
    this.count = 0;
    this.limit = newLimit;
    // 3. 遍历oldStorage中所有的bucket
    oldStorage.forEach((bucket) => {
      // 3.1. 判断bucket是否存在
      if (!bucket) {
        return;
      }
      // 3.2. 重新插入
      for (let i = 0; i < bucket.length; i++) {
        const [k, v] = bucket[i];
        this.put(k, v);
      }
    });
  }
  /**
   * 插入/修改元素：HashMap -> { key, value }
   * @param {*} key
   * @param {*} value
   */
  put(key, value) {
    // 1. 根据key获取对应的index
    const index = this.hashFunc(key, this.limit);
    // 2. 根据index获取对应的bucket
    let bucket = this.storage[index];
    // 3. 判断bucket是否存在，如果不存在则创建bucket（为了低耦合，这里直接用数组）
    if (!bucket) {
      bucket = [];
      this.storage[index] = bucket;
    }
    // 4. 判断是否是修改数据
    for (let i = 0; i < bucket.length; i++) {
      const [k] = bucket[i];
      // 修改
      if (k === key) {
        bucket[i][1] = value;
        return;
      }
    }
    // 5. 进行添加操作
    bucket.push([key, value]);
    this.count++;
    // 6. 判断是否需要进行扩容操作
    if (this.count > this.limit * MAX_LOAD_FACTOR) {
      const newSize = this.limit * 2;
      const newPrime = this.getPrime(newSize);
      this.resize(newPrime);
    }
  }
  /**
   * 获取元素
   * @param {*} key
   */
  get(key) {
    // 1. 根据key获取index
    const index = this.hashFunc(key, this.limit);
    // 2. 根据index获取bucket
    const bucket = this.storage[index];
    // 3. 判断bucket是否存在
    if (!bucket) {
      return null;
    }
    // 4. 有bucket，那么就进行线性查找
    for (let i = 0; i < bucket.length; i++) {
      const [k, v] = bucket[i];
      if (k === key) {
        return v;
      }
    }
    // 5. 依然没找到，那么返回null
    return null;
  }
  /**
   * 删除元素
   * @param {*}} key
   */
  remove(key) {
    // 1. 根据key获取index
    const index = this.hashFunc(key, this.limit);
    // 2. 根据index获取bucket
    const bucket = this.storage[index];
    // 3. 判断bucket是否存在
    if (!bucket) {
      return null;
    }
    // 4. 线性查找，删除元素并将其返回
    for (let i = 0; i < bucket.length; i++) {
      const [k, v] = bucket[i];
      if (k === key) {
        bucket.splice(i, 1);
        this.count--;
        // 缩小容量
        if (this.limit > 7 && this.count < this.limit * MIN_LOAD_FACTOR) {
          const newSize = Math.floor(this.limit / 2);
          const newPrime = this.getPrime(newSize);
          this.resize(newPrime);
        }
        return v;
      }
    }
    // 5. 依然没找到，那么返回null
    return null;
  }
  /**
   * 是否为空
   * @returns
   */
  isEmpty() {
    return this.count === 0;
  }
  /**
   * 长度
   * @returns
   */
  size() {
    return this.count;
  }
}
```

