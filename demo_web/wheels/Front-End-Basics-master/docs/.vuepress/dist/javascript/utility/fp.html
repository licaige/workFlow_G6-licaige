<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数式编程 | Front-End-Basics</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="陈方旭的个人文档">
    
    <link rel="preload" href="/assets/css/0.styles.495d9abf.css" as="style"><link rel="preload" href="/assets/js/app.26ddf859.js" as="script"><link rel="preload" href="/assets/js/2.0a0a1bce.js" as="script"><link rel="preload" href="/assets/js/158.dd412e9f.js" as="script"><link rel="prefetch" href="/assets/js/10.7fd8ce8b.js"><link rel="prefetch" href="/assets/js/100.e2e655f5.js"><link rel="prefetch" href="/assets/js/101.03d0acad.js"><link rel="prefetch" href="/assets/js/102.2f60b5a6.js"><link rel="prefetch" href="/assets/js/103.c5e7eb0b.js"><link rel="prefetch" href="/assets/js/104.d493f2a3.js"><link rel="prefetch" href="/assets/js/105.c27b5e53.js"><link rel="prefetch" href="/assets/js/106.819ca6ce.js"><link rel="prefetch" href="/assets/js/107.d60fe526.js"><link rel="prefetch" href="/assets/js/108.33cfb7ed.js"><link rel="prefetch" href="/assets/js/109.004e3009.js"><link rel="prefetch" href="/assets/js/11.b58cc63a.js"><link rel="prefetch" href="/assets/js/110.ffa5fbbc.js"><link rel="prefetch" href="/assets/js/111.f3073fff.js"><link rel="prefetch" href="/assets/js/112.3c09cbc0.js"><link rel="prefetch" href="/assets/js/113.b19590e6.js"><link rel="prefetch" href="/assets/js/114.b802a814.js"><link rel="prefetch" href="/assets/js/115.ef4a42a7.js"><link rel="prefetch" href="/assets/js/116.ba312c6c.js"><link rel="prefetch" href="/assets/js/117.3c81d39e.js"><link rel="prefetch" href="/assets/js/118.06a46444.js"><link rel="prefetch" href="/assets/js/119.49125678.js"><link rel="prefetch" href="/assets/js/12.588d1122.js"><link rel="prefetch" href="/assets/js/120.6caa767c.js"><link rel="prefetch" href="/assets/js/121.cad653d5.js"><link rel="prefetch" href="/assets/js/122.b54e599c.js"><link rel="prefetch" href="/assets/js/123.bcf93ede.js"><link rel="prefetch" href="/assets/js/124.f7768fe4.js"><link rel="prefetch" href="/assets/js/125.2dc9e948.js"><link rel="prefetch" href="/assets/js/126.a0a3e110.js"><link rel="prefetch" href="/assets/js/127.32cae0cf.js"><link rel="prefetch" href="/assets/js/128.391dd8b6.js"><link rel="prefetch" href="/assets/js/129.d7ec7c07.js"><link rel="prefetch" href="/assets/js/13.f855b112.js"><link rel="prefetch" href="/assets/js/130.514a6b2e.js"><link rel="prefetch" href="/assets/js/131.af6e4770.js"><link rel="prefetch" href="/assets/js/132.b5eb4428.js"><link rel="prefetch" href="/assets/js/133.278c6032.js"><link rel="prefetch" href="/assets/js/134.8b4fbfea.js"><link rel="prefetch" href="/assets/js/135.af8c3010.js"><link rel="prefetch" href="/assets/js/136.e8d50939.js"><link rel="prefetch" href="/assets/js/137.062c9279.js"><link rel="prefetch" href="/assets/js/138.748f625e.js"><link rel="prefetch" href="/assets/js/139.c8d452ba.js"><link rel="prefetch" href="/assets/js/14.706c60f4.js"><link rel="prefetch" href="/assets/js/140.e3d090bc.js"><link rel="prefetch" href="/assets/js/141.76309f02.js"><link rel="prefetch" href="/assets/js/142.badcfbea.js"><link rel="prefetch" href="/assets/js/143.9444172a.js"><link rel="prefetch" href="/assets/js/144.6811b2cb.js"><link rel="prefetch" href="/assets/js/145.760e53a6.js"><link rel="prefetch" href="/assets/js/146.6a021bf1.js"><link rel="prefetch" href="/assets/js/147.1a09e987.js"><link rel="prefetch" href="/assets/js/148.4a2102a6.js"><link rel="prefetch" href="/assets/js/149.e4992bc8.js"><link rel="prefetch" href="/assets/js/15.dddbfaa5.js"><link rel="prefetch" href="/assets/js/150.bf99144d.js"><link rel="prefetch" href="/assets/js/151.6cae69ac.js"><link rel="prefetch" href="/assets/js/152.e5a32ff0.js"><link rel="prefetch" href="/assets/js/153.5ec16bda.js"><link rel="prefetch" href="/assets/js/154.b99016d2.js"><link rel="prefetch" href="/assets/js/155.330ba388.js"><link rel="prefetch" href="/assets/js/156.272c4fdd.js"><link rel="prefetch" href="/assets/js/157.37f7adc8.js"><link rel="prefetch" href="/assets/js/159.92108a41.js"><link rel="prefetch" href="/assets/js/16.e52b2f0e.js"><link rel="prefetch" href="/assets/js/160.691be0a2.js"><link rel="prefetch" href="/assets/js/161.25591efd.js"><link rel="prefetch" href="/assets/js/162.d383ff2b.js"><link rel="prefetch" href="/assets/js/163.b086f272.js"><link rel="prefetch" href="/assets/js/164.51ec1769.js"><link rel="prefetch" href="/assets/js/165.5101617a.js"><link rel="prefetch" href="/assets/js/166.4adb994b.js"><link rel="prefetch" href="/assets/js/167.d0ab2ea3.js"><link rel="prefetch" href="/assets/js/168.57a9a221.js"><link rel="prefetch" href="/assets/js/169.d6830258.js"><link rel="prefetch" href="/assets/js/17.0668268a.js"><link rel="prefetch" href="/assets/js/170.a1c94b18.js"><link rel="prefetch" href="/assets/js/171.758c4100.js"><link rel="prefetch" href="/assets/js/172.a390e082.js"><link rel="prefetch" href="/assets/js/173.6a612dab.js"><link rel="prefetch" href="/assets/js/174.323cd630.js"><link rel="prefetch" href="/assets/js/175.d2d192f7.js"><link rel="prefetch" href="/assets/js/176.83699347.js"><link rel="prefetch" href="/assets/js/177.58e2a96f.js"><link rel="prefetch" href="/assets/js/178.f20d6711.js"><link rel="prefetch" href="/assets/js/179.246c5b5d.js"><link rel="prefetch" href="/assets/js/18.1ec934a2.js"><link rel="prefetch" href="/assets/js/180.99a7cd1a.js"><link rel="prefetch" href="/assets/js/181.8b2ed6c7.js"><link rel="prefetch" href="/assets/js/182.465f06b6.js"><link rel="prefetch" href="/assets/js/183.d5e9d2a9.js"><link rel="prefetch" href="/assets/js/184.34cddded.js"><link rel="prefetch" href="/assets/js/185.c7a7ab75.js"><link rel="prefetch" href="/assets/js/186.dd1d0e7d.js"><link rel="prefetch" href="/assets/js/187.9655d4c4.js"><link rel="prefetch" href="/assets/js/188.e51e42cf.js"><link rel="prefetch" href="/assets/js/189.7107e215.js"><link rel="prefetch" href="/assets/js/19.b3a69aa1.js"><link rel="prefetch" href="/assets/js/190.aea451e0.js"><link rel="prefetch" href="/assets/js/191.4aa4329e.js"><link rel="prefetch" href="/assets/js/192.d1eb7eb6.js"><link rel="prefetch" href="/assets/js/193.84be6ed1.js"><link rel="prefetch" href="/assets/js/194.d27bdfcd.js"><link rel="prefetch" href="/assets/js/195.bd0371b6.js"><link rel="prefetch" href="/assets/js/20.4833415c.js"><link rel="prefetch" href="/assets/js/21.623aae45.js"><link rel="prefetch" href="/assets/js/22.0f922dba.js"><link rel="prefetch" href="/assets/js/23.c71d9286.js"><link rel="prefetch" href="/assets/js/24.6331e619.js"><link rel="prefetch" href="/assets/js/25.aebbd191.js"><link rel="prefetch" href="/assets/js/26.4a350a9e.js"><link rel="prefetch" href="/assets/js/27.f0593bbf.js"><link rel="prefetch" href="/assets/js/28.3a3be2a5.js"><link rel="prefetch" href="/assets/js/29.600006cd.js"><link rel="prefetch" href="/assets/js/3.de0ded1b.js"><link rel="prefetch" href="/assets/js/30.fd1bf4df.js"><link rel="prefetch" href="/assets/js/31.c17eec63.js"><link rel="prefetch" href="/assets/js/32.0beb9489.js"><link rel="prefetch" href="/assets/js/33.4b356132.js"><link rel="prefetch" href="/assets/js/34.426a3957.js"><link rel="prefetch" href="/assets/js/35.9e58f8ae.js"><link rel="prefetch" href="/assets/js/36.b304f65d.js"><link rel="prefetch" href="/assets/js/37.102918ae.js"><link rel="prefetch" href="/assets/js/38.b306427b.js"><link rel="prefetch" href="/assets/js/39.8a7ddc82.js"><link rel="prefetch" href="/assets/js/4.6aeff477.js"><link rel="prefetch" href="/assets/js/40.15b85e4a.js"><link rel="prefetch" href="/assets/js/41.7194c6a5.js"><link rel="prefetch" href="/assets/js/42.40d604fe.js"><link rel="prefetch" href="/assets/js/43.1308a197.js"><link rel="prefetch" href="/assets/js/44.a600e34c.js"><link rel="prefetch" href="/assets/js/45.07f1aea4.js"><link rel="prefetch" href="/assets/js/46.ef1cd999.js"><link rel="prefetch" href="/assets/js/47.31ae8f23.js"><link rel="prefetch" href="/assets/js/48.546ddc2b.js"><link rel="prefetch" href="/assets/js/49.6256155f.js"><link rel="prefetch" href="/assets/js/5.3017579e.js"><link rel="prefetch" href="/assets/js/50.9023bd20.js"><link rel="prefetch" href="/assets/js/51.9c0ab442.js"><link rel="prefetch" href="/assets/js/52.e2cc1558.js"><link rel="prefetch" href="/assets/js/53.2a34ee52.js"><link rel="prefetch" href="/assets/js/54.94919a07.js"><link rel="prefetch" href="/assets/js/55.cdcde14b.js"><link rel="prefetch" href="/assets/js/56.402b91d1.js"><link rel="prefetch" href="/assets/js/57.1c816075.js"><link rel="prefetch" href="/assets/js/58.7bc6c53a.js"><link rel="prefetch" href="/assets/js/59.98cd16d3.js"><link rel="prefetch" href="/assets/js/6.c66a9c0d.js"><link rel="prefetch" href="/assets/js/60.c6b1fedf.js"><link rel="prefetch" href="/assets/js/61.77a37644.js"><link rel="prefetch" href="/assets/js/62.33adbccc.js"><link rel="prefetch" href="/assets/js/63.46e827aa.js"><link rel="prefetch" href="/assets/js/64.fccc6652.js"><link rel="prefetch" href="/assets/js/65.784409bc.js"><link rel="prefetch" href="/assets/js/66.0ff33975.js"><link rel="prefetch" href="/assets/js/67.71025c8a.js"><link rel="prefetch" href="/assets/js/68.bc956963.js"><link rel="prefetch" href="/assets/js/69.0835dc3a.js"><link rel="prefetch" href="/assets/js/7.abbb8cf3.js"><link rel="prefetch" href="/assets/js/70.b4997331.js"><link rel="prefetch" href="/assets/js/71.c555d255.js"><link rel="prefetch" href="/assets/js/72.410045e4.js"><link rel="prefetch" href="/assets/js/73.f11bc054.js"><link rel="prefetch" href="/assets/js/74.b0b7f602.js"><link rel="prefetch" href="/assets/js/75.564b469f.js"><link rel="prefetch" href="/assets/js/76.dc701916.js"><link rel="prefetch" href="/assets/js/77.2f2e86ba.js"><link rel="prefetch" href="/assets/js/78.293c88ac.js"><link rel="prefetch" href="/assets/js/79.188e3f3f.js"><link rel="prefetch" href="/assets/js/8.5ca23337.js"><link rel="prefetch" href="/assets/js/80.12817fd5.js"><link rel="prefetch" href="/assets/js/81.20822295.js"><link rel="prefetch" href="/assets/js/82.827507e9.js"><link rel="prefetch" href="/assets/js/83.2669bc92.js"><link rel="prefetch" href="/assets/js/84.587c39a1.js"><link rel="prefetch" href="/assets/js/85.acc07148.js"><link rel="prefetch" href="/assets/js/86.b0c041c1.js"><link rel="prefetch" href="/assets/js/87.d437a0f0.js"><link rel="prefetch" href="/assets/js/88.6e542ac8.js"><link rel="prefetch" href="/assets/js/89.dc44df50.js"><link rel="prefetch" href="/assets/js/9.8b8ba95c.js"><link rel="prefetch" href="/assets/js/90.61a1b726.js"><link rel="prefetch" href="/assets/js/91.3f4b2a8a.js"><link rel="prefetch" href="/assets/js/92.cd3aa7ff.js"><link rel="prefetch" href="/assets/js/93.ce269678.js"><link rel="prefetch" href="/assets/js/94.b5bf35e9.js"><link rel="prefetch" href="/assets/js/95.412f527b.js"><link rel="prefetch" href="/assets/js/96.9af6b5f0.js"><link rel="prefetch" href="/assets/js/97.ffe88ff0.js"><link rel="prefetch" href="/assets/js/98.9c55d95f.js"><link rel="prefetch" href="/assets/js/99.b9b8c7f7.js">
    <link rel="stylesheet" href="/assets/css/0.styles.495d9abf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="Front-End-Basics" class="logo"> <span class="site-name can-hide">Front-End-Basics</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/article/" class="nav-link">
  捡贝壳
</a></div> <a href="https://github.com/qiqihaobenben/Front-End-Basics" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础篇</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>应用篇</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/javascript/utility/fp.html" aria-current="page" class="active sidebar-link">函数式编程</a></li><li><a href="/javascript/utility/cache.html" class="sidebar-link">三种本地存储方式和一些扩展</a></li><li><a href="/javascript/utility/module.html" class="sidebar-link">JavaScript 的模块</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构和算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TypeScript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="函数式编程"><a href="#函数式编程" class="header-anchor">#</a> 函数式编程</h2> <h3 id="什么是函数式编程-为何它重要"><a href="#什么是函数式编程-为何它重要" class="header-anchor">#</a> 什么是函数式编程？为何它重要？</h3> <h4 id="数学中的函数"><a href="#数学中的函数" class="header-anchor">#</a> 数学中的函数</h4> <div class="language- extra-class"><pre class="language-text"><code>f(x) = y
// 一个函数f，以x为参数，并返回输出y
</code></pre></div><p>关键点：</p> <ul><li>函数必须总是接受一个参数</li> <li>函数必须总是返回一个值</li> <li>函数应该依据接收到的参数（例如x）而不是外部环境运行</li> <li>对于一个给定的x，只会输出唯一的一个y</li></ul> <p>函数式编程技术主要基于数学函数和它的思想，所以要理解函数式编程，先了解数学函数是有必要的。</p> <h3 id="函数式编程的定义"><a href="#函数式编程的定义" class="header-anchor">#</a> 函数式编程的定义</h3> <p><strong>函数</strong>是一段可以通过其名称被调用的代码。它可以接受参数，并返回值。</p> <p>与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）一样，函数式编程（Functional programming）也是一种编程范式。我们能够以此创建仅依赖输入就可以完成自身逻辑的函数。这保证了当函数被多次调用时仍然返回相同的结果（引用透明性）。函数不会改变任何外部环境的变量，这将产生可缓存的，可测试的代码库。</p> <h3 id="函数式编程具有以下特征"><a href="#函数式编程具有以下特征" class="header-anchor">#</a> 函数式编程具有以下特征</h3> <h4 id="_1、引用透明性"><a href="#_1、引用透明性" class="header-anchor">#</a> 1、引用透明性</h4> <p>所有的函数对于相同的输入都将返回相同的值，函数的这一属性被称为<strong>引用透明性（Referential Transparency）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// 引用透明的例子，函数identity无论输入什么，都会原封不动的返回
var identity = (i) =&gt; {return i}
</code></pre></div><h5 id="替换模型"><a href="#替换模型" class="header-anchor">#</a> 替换模型</h5> <p>把一个引用透明的函数用于其他函数调用之间。</p> <p><code>sum(4,5) + identity(1)</code></p> <p>根据引用透明的定义，我们可以把上面的语句换成：</p> <p><code>sum(4,5) + 1</code></p> <p>该过程被称为替换模型（Substitution Model）,因为函数的逻辑不依赖其他全局变量，你可以直接替换函数的结果，这与它的值是一样的。所以，这使得<strong>并发代码</strong>和<strong>缓存</strong>成为可能。</p> <p><strong>并发代码：</strong> 并发运行的时候，如果依赖了全局数据，要保证数据一致，必须同步，而且必要时需要锁机制。遵循引用透明的函数只依赖参数的输入，所以可以自由的运行。</p> <p><strong>缓存：</strong> 由于函数会为给定的输入返回相同的值，实际上我们就能缓存它了。比如实现一个计算给定数值的阶乘的函数，我们就可以把每次阶乘的结果缓存下来，下一次直接用，就不用计算了。比如第一次输入5，结果是120，第二次输入5，我们知道结果必然是120，所以就可以返回已缓存的值，而不必再计算一次。</p> <h4 id="_2、声明式和抽象"><a href="#_2、声明式和抽象" class="header-anchor">#</a> 2、声明式和抽象</h4> <p>函数式编程主张声明式编程和编写抽象的代码。</p> <h5 id="比较命令式和声明式"><a href="#比较命令式和声明式" class="header-anchor">#</a> 比较命令式和声明式</h5> <div class="language- extra-class"><pre class="language-text"><code>// 有一个数组，要遍历它并把它打印到控制台

/*命令式*/
var array = [1,2,3]
for(var i = 0; i &lt; array.length; i++)
console(array[i]) // 打印 1,2,3

// 命令式编程中，我们精确的告诉程序应该“如何”做：获取数组的长度，通过数组的长度循环数组，在每一次循环中用索引获取每一个数组元素，然后打印出来。
// 但是我们的任务只是打印出数组的元素。并不是要告诉编译器要如何实现一个遍历。



/*声明式*/
var array = [1,2,3]
array.forEach((element) =&gt; console.log(element)) // 打印 1,2,3

// 我们使用了一个处理“如何”做的抽象函数，然后我们就能只关心做“什么”了
</code></pre></div><h5 id="函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。"><a href="#函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。" class="header-anchor">#</a> 函数式编程主张以抽象的方式创建函数，例如上文的forEach，这些函数能够在代码的其他部分被重用。</h5> <h4 id="_3、纯函数"><a href="#_3、纯函数" class="header-anchor">#</a> 3、纯函数</h4> <p>大多数函数式编程的好处来自于编写纯函数，<strong>纯函数</strong>是对给定的输入返回相同的输出的函数，并且纯函数不应依赖任何外部变量，也不应改变任何外部变量。</p> <h5 id="纯函数的好处"><a href="#纯函数的好处" class="header-anchor">#</a> 纯函数的好处</h5> <ol><li>纯函数产生容易测试的代码</li> <li>纯函数容易写出合理的代码</li> <li>纯函数容易写出并发代码
纯函数总是允许我们并发的执行代码。因为纯函数不会改变它的环境，这意味着我们根本不需要担心同步问题。</li> <li>纯函数的输出结果可缓存
既然纯函数总是为给定的输入返回相同的输出，那么我们就能够缓存函数的输出。</li></ol> <h2 id="高阶函数"><a href="#高阶函数" class="header-anchor">#</a> 高阶函数</h2> <h3 id="数据和数据类型"><a href="#数据和数据类型" class="header-anchor">#</a> 数据和数据类型</h3> <p>程序作用于数据，数据对于程序的执行很重要。每种编程语言都有数据类型。这些数据类型能够存储数据并允许程序作用其中。</p> <h3 id="javascript中函数是一等公民-first-class-citizens"><a href="#javascript中函数是一等公民-first-class-citizens" class="header-anchor">#</a> JavaScript中函数是一等公民(First Class Citizens)</h3> <p>**当一门语言允许函数作为任何其他数据类型使用时，函数被称为一等公民。**也就是说函数可被赋值给变量，作为参数传递，也可被其他函数返回。</p> <p>函数作为JavaScript的一种数据类型，由于函数是类似String的数据类型，所以我们能把函数存入一个变量，能够作为函数的参数进行传递。所以JavaScript中函数是一等公民。</p> <h3 id="高阶函数的定义"><a href="#高阶函数的定义" class="header-anchor">#</a> 高阶函数的定义</h3> <p>接受另一个函数作为其参数的函数称为高阶函数(Higher-Order-Function)，或者说高阶函数是接受函数作为参数并且/或者返回函数作为输出的函数。</p> <h3 id="抽象和高阶函数"><a href="#抽象和高阶函数" class="header-anchor">#</a> 抽象和高阶函数</h3> <p>一般而言，高阶函数通常用于抽象通用的问题，换句话说，高阶函数就是定义抽象。</p> <p><strong>抽象</strong> ： 在软件工程和计算机科学中，抽象是一种管理计算机系统复杂性的技术。 通过建立一个人与系统进行交互的复杂程度，把更复杂的细节抑制在当前水平之下。简言之，抽象让我们专注于预定的目标而无须关心底层的系统概念。</p> <blockquote><p>例如：你在编写一个涉及数值操作的代码，你不会对底层硬件的数字表现方式到底是16位还是32位整数有很深的了解，包括这些细节在哪里屏蔽。因为它们被抽象出来了，只留下了简单的数字给我们使用。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>// 用forEach抽象出遍历数组的操作
const forEach = (array,fn) =&gt; {
  let i;
  for(i=0;i&lt;array.length;i++) {
    fn(array[i])
  }
}

// 用户不需要理解forEach是如何实现遍历的，如此问题就被抽象出来了。
//例如，想要打印出数组的每一项
let array = [1,2,3]
forEach(array,(data) =&gt; console.log(data))
</code></pre></div><h3 id="闭包和高阶函数"><a href="#闭包和高阶函数" class="header-anchor">#</a> 闭包和高阶函数</h3> <p>什么是闭包？简言之，**闭包就是一个内部函数。**什么是内部函数？就是在另一个函数内部的函数。</p> <p>闭包的强大之处在于它对作用域链（或作用域层级）的访问。从技术上讲，闭包有3个可访问的作用域。</p> <p>(1) 在它自身声明之内声明的变量</p> <p>(2) 对全局变量的访问</p> <p>(3) 对外部函数变量的访问（关键点）</p> <p><strong>实例一</strong>：假设你再遍历一个来自服务器的数组，并发现数据错了。你想调试一下，看看数组里面究竟包含了什么。不要用命令式的方法，要用函数式的方法来实现。这里就需要一个 tap 函数。</p> <div class="language- extra-class"><pre class="language-text"><code>const tap = (value) =&gt; {
  return (fn) =&gt; {
    typeof fn === 'function' &amp;&amp; fn(value)
    console.log(value)
  }
}

// 没有调试之前
forEach(array, data =&gt; {
  console.log(data + data)
})

// 在 forEach 中使用 tap 调试
forEach(array, data =&gt; {
  tap(data)(() =&gt; {
    console.log(data + data)
  })
})
</code></pre></div><p>完成一个简单的reduce函数</p> <div class="language- extra-class"><pre class="language-text"><code>const reduce = (array,fn,initialValue) =&gt; {
  let accumulator;
  if(initialValue != undefined)
    accumulator = initialValue
  else
    accumulator = array[0]

  if(initialValue === undefined)
    for(let i = 1; i &lt; array.length; i++)
      accumulator = fn(accumulator, array[i])
  else
    for(let value of array)
      accumulator = fn(accumulator,value)
  return accumulator
}

console.log(reduce([1,2,3], (accumulator,value) =&gt; accumulator + value))
// 打印出6
</code></pre></div><h2 id="柯里化与偏应用"><a href="#柯里化与偏应用" class="header-anchor">#</a> 柯里化与偏应用</h2> <h3 id="一些概念"><a href="#一些概念" class="header-anchor">#</a> 一些概念</h3> <h4 id="一元函数"><a href="#一元函数" class="header-anchor">#</a> 一元函数</h4> <p>只接受一个参数的函数称为一元(unary)函数。</p> <h4 id="二元函数"><a href="#二元函数" class="header-anchor">#</a> 二元函数</h4> <p>只接受两个参数的函数称为二元(binary)函数。</p> <h4 id="变参函数"><a href="#变参函数" class="header-anchor">#</a> 变参函数</h4> <p>变参函数是接受可变数量的函数。</p> <h3 id="柯里化"><a href="#柯里化" class="header-anchor">#</a> 柯里化</h3> <p>柯里化是把一个多参数函数转换为一个嵌套的一元函数的过程。</p> <p>例如</p> <div class="language- extra-class"><pre class="language-text"><code>// 一个多参数函数
const add = (x,y) =&gt; x + y;
add(2,3)

// 一个嵌套的一元函数
const addCurried = x =&gt; y =&gt; x + y;
addCurried(2)(3)

// 然后我们写一个高阶函数，把 add 转换成 addCurried 的形式。
const curry = (binaryFn) =&gt; {
  return function (firstArg) {
    return function (secondArg) {
      return binaryFn(firstArg,secondArg)
    }
  }
}
let autoCurriedAdd = carry(add)
autoCurriedAdd(2)(3)
</code></pre></div><p>上面只是简单实现了一个二元函数的柯里化，下面我们要实现一个更多参数的函数的柯里化。</p> <div class="language- extra-class"><pre class="language-text"><code>const curry = (fn) =&gt; {
  if (typeof fn !== 'function') {
    throw Error('No function provided')
  }
  return function curriedFn (...args) {
    // 判断当前接受的参数是不是小于进行柯里化的函数的参数个数
    if(args.length &lt; fn.length) {
      // 如果小于的话就返回一个函数再去接收剩下的参数
      return function (...argsOther) {
        return curriedFn.apply(null, args.concat(argsOther))
      }
    }else {
      return fn.apply(null,args)
    }
  }
}

 const multiply = (x,y,z) =&gt; x * y * z;
 console.log(curry(multiply)(2)(3)(4))
</code></pre></div><p>柯里化的应用实例：从数组中找出含有数字的元素</p> <div class="language- extra-class"><pre class="language-text"><code>let match = curry(function (expr,str) {
  return str.match(expr)
})
let hasNumber = match(/[0-9]+/)

let initFilter = curry(function (fn,array) {
  return array.filter(fn)
})

let findNumberInArray = initFilter(hasNumber)
console.log(findNumberInArray(['aaa', 'bb2', '33c', 'ddd', ]))
// 打印 [ 'bb2', '33c' ]
</code></pre></div><h3 id="偏应用"><a href="#偏应用" class="header-anchor">#</a> 偏应用</h3> <p>我们上面设计的柯里化函数总是在最后接受一个数组，这使得它能接受的参数列表只能是从最左到最右。</p> <p>但是有时候，我们不能按照从左到右的这样严格传入参数，或者只是想部分地应用函数参数。这里我们就需要用到偏应用这个概念，它允许开发者部分地应用函数参数。</p> <div class="language- extra-class"><pre class="language-text"><code>const partial = function (fn, ...partialArgs) {
  return function (...fullArguments) {
    let args = partialArgs
    let arg = 0;
    for(let i = 0; i &lt; args.length &amp;&amp; arg &lt; fullArguments.length; i++) {
      if(args[i] === undefined) {
        args[i] = fullArguments[arg++]
      }
    }
    return fn.apply(null,args)
  }
}
</code></pre></div><p>偏应用的示例：</p> <div class="language- extra-class"><pre class="language-text"><code>// 打印某个格式化的JSON
let prettyPrintJson = partial(JSON.stringify,undefined,null,2)
console.log(prettyPrintJson({name:'fangxu',gender:'male'}))

// 打印出
{
  &quot;name&quot;: &quot;fangxu&quot;,
  &quot;gender&quot;: &quot;male&quot;
}
</code></pre></div><h2 id="组合与管道"><a href="#组合与管道" class="header-anchor">#</a> 组合与管道</h2> <h3 id="unix的理念"><a href="#unix的理念" class="header-anchor">#</a> Unix的理念</h3> <ol><li>每个程序只做好一件事情，为了完成一项新的任务，重新构建要好于在复杂的旧程序中添加新“属性”。</li> <li>每个程序的输出应该是另一个尚未可知的程序的输入。</li> <li>每一个基础函数都需要接受一个参数并返回数据。</li></ol> <h3 id="组合-compose"><a href="#组合-compose" class="header-anchor">#</a> 组合(compose)</h3> <div class="language- extra-class"><pre class="language-text"><code>const compose = (...fns) =&gt; {
  return (value) =&gt; reduce(fns.reverse(),(acc,fn) =&gt; fn(acc), value)
}
</code></pre></div><p>compose 组合的函数，是按照传入的顺序从右到左调用的。所以传入的 fns 要先 reverse 一下，然后我们用到了reduce ，reduce 的累加器初始值是 value ，然后会调用 <code>(acc,fn) =&gt; fn(acc)</code>, 依次从 fns 数组中取出 fn ，将累加器的当前值传入 fn ，即把上一个函数的返回值传递到下一个函数的参数中。</p> <p>组合的实例：</p> <div class="language- extra-class"><pre class="language-text"><code>let splitIntoSpace = (str) =&gt; str.split(' ')
let count = (array) =&gt; array.length
const countWords = composeN(count, splitIntoSpace)
console.log(countWords('make smaller or less in amount'))
// 打印 6
</code></pre></div><h3 id="管道-序列"><a href="#管道-序列" class="header-anchor">#</a> 管道/序列</h3> <p>compose 函数的数据流是从右往左的，最右侧的先执行。当然，我们还可以让最左侧的函数先执行，最右侧的函数最后执行。这种从左至右处理数据流的过程称为管道（pipeline）或序列(sequence)。</p> <div class="language- extra-class"><pre class="language-text"><code>// 跟compose的区别，只是没有调用fns.reverse()
const pipe = (...fns) =&gt; (value) =&gt; reduce(fns,(acc,fn) =&gt; fn(acc),value)
</code></pre></div><h2 id="函子"><a href="#函子" class="header-anchor">#</a> 函子</h2> <h3 id="什么是函子-functor"><a href="#什么是函子-functor" class="header-anchor">#</a> 什么是函子(Functor)？</h3> <p><strong>定义</strong>：函子是一个普通对象（在其它语言中，可能是一个类），它实现了map函数，在遍历每个对象值的时候生成一个新对象。</p> <h4 id="实现一个函子"><a href="#实现一个函子" class="header-anchor">#</a> 实现一个函子</h4> <p>1、简言之，函子是一个持有值的容器。而且函子是一个普通对象。我们就可以创建一个容器（也就是对象），让它能够持有任何传给它的值。</p> <div class="language- extra-class"><pre class="language-text"><code>const Container = function (value) {
  this.value = value
}

let testValue = new Container(1)
// =&gt; Container {value:1}
</code></pre></div><p>我们给 Container 增加一个静态方法，它可以为我们在创建新的 Containers 时省略 new 关键字。</p> <div class="language- extra-class"><pre class="language-text"><code>Container.of = function (value) {
  return new Container(value)
}

// 现在我们就可以这样来创建
Container.of(1)
// =&gt; Container {value:1}
</code></pre></div><p>2、函子需要实现 map 方法，具体的实现是，map 函数从 Container 中取出值，传入的函数把取出的值作为参数调用，并将结果放回 Container。</p> <blockquote><p>为什么需要 map 函数，我们上面实现的 Container 仅仅是持有了传给它的值。但是持有值的行为几乎没有任何应用场景，而 map 函数发挥的作用就是，允许我们使用当前 Container 持有的值调用任何函数。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>Container.prototype.map = function (fn) {
  return Container.of(fn(this.value))
}

// 然后我们实现一个数字的 double 操作
let double = (x) =&gt; x + x;
Container.of(3).map(double)
// =&gt; Container {value: 6}
</code></pre></div><p>3、map返回了一传入函数的执行结果为值的 Container 实例，所以我们可以链式操作。</p> <div class="language- extra-class"><pre class="language-text"><code>Container.of(3).map(double).map(double).map(double)
// =&gt; Container {value: 24}
</code></pre></div><p><strong>通过以上的实现，我们可以发现，函子就是一个实现了map契约的对象。函子是一个寻求契约的概念，该契约很简单，就是实现 map 。根据实现 map 函数的方式不同，会产生不同类型的函子，如 MayBe 、 Either</strong></p> <p>函子可以用来做什么？之前我们用tap函数来函数式的解决代码报错的调试问题，如何更加函数式的处理代码中的问题，那就需要用到下面我们说的MayBe函子</p> <h3 id="maybe-函子"><a href="#maybe-函子" class="header-anchor">#</a> MayBe 函子</h3> <p>让我们先写一个upperCase函数来假设一种场景</p> <div class="language- extra-class"><pre class="language-text"><code>let value = 'string';
function upperCase(value) {
  // 为了避免报错，我们得写这么一个判断
  if(value != null || value != undefined)
    return value.toUpperCase()
}
upperCase(value)
// =&gt; STRING
</code></pre></div><p>如上面所示，我们代码中经常需要判断一些<code>null</code>和<code>undefined</code>的情况。下面我们来看一下MayBe函子的实现。</p> <div class="language- extra-class"><pre class="language-text"><code>// MayBe 跟上面的 Container 很相似
export const MayBe = function (value) {
  this.value = value
}
MayBe.of = function (value) {
  return new MayBe(value)
}
// 多了一个isNothing
MayBe.prototype.isNoting = function () {
  return this.value === null || this.value === undefined;
}
// 函子必定有 map,但是 map 的实现方式可能不同
MayBe.prototype.map = function(fn) {
  return this.isNoting()?MayBe.of(null):MayBe.of(fn(this.value))
}

// MayBe应用
let value = 'string';
MayBe.of(value).map(upperCase)
// =&gt; MayBe { value: 'STRING' }
let nullValue = null
MayBe.of(nullValue).map(upperCase)
// 不会报错 MayBe { value: null }
</code></pre></div><h3 id="either-函子"><a href="#either-函子" class="header-anchor">#</a> Either 函子</h3> <div class="language- extra-class"><pre class="language-text"><code>MayBe.of(&quot;tony&quot;)
  .map(() =&gt; undefined)
  .map((x)f =&gt; &quot;Mr. &quot; + x)
</code></pre></div><p>上面的代码结果是 <code>MyaBe {value: null}</code>,这只是一个简单的例子，我们可以想一下，如果代码比较复杂，我们是不知道到底是哪一个分支在检查 undefined 和 null 值时执行失败了。这时候我们就需要 Either 函子了，它能解决分支拓展问题。</p> <div class="language- extra-class"><pre class="language-text"><code>const Nothing = function (value) {
  this.value = value;
}
Nothing.of = function (value) {
  return new Nothing(value)
}
Nothing.prototype.map = function (fn) {
  return this;
}
const Some = function (value) {
  this.value = value;
}
Some.of = function (value) {
  return new Some(value)
}
Some.prototype.map = function (fn) {
  return Some.of(fn(this.value));
}

const Either = {
  Some,
  Nothing
}

</code></pre></div><h3 id="pointed-函子"><a href="#pointed-函子" class="header-anchor">#</a> Pointed 函子</h3> <p>函子只是一个实现了 map 契约的接口。Pointed 函子也是一个函子的子集，它具有实现了 of 契约的接口。 我们在 MayBe 和 Either 中也实现了 of 方法，用来在创建 Container 时不使用 new 关键字。所以 MayBe 和 Either 都可称为 Pointed 函子。</p> <blockquote><p>ES6 增加了 Array.of， 这使得数组成为了一个 Pointed 函子。</p></blockquote> <h3 id="monad-函子"><a href="#monad-函子" class="header-anchor">#</a> Monad 函子</h3> <p>MayBe 函子很可能会出现嵌套，如果出现嵌套后，我们想要继续操作真正的value是有困难的。必须深入到 MayBe 内部进行操作。</p> <div class="language- extra-class"><pre class="language-text"><code>let joinExample = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }

// 这个时候我们想让5加上4，需要深入 MayBe 函子内部
joinExample.map((insideMayBe) =&gt; {
  return insideMayBe.map((value) =&gt; value + 4)
})
// =&gt; MayBe { value: MayBe { value: 9 } }
</code></pre></div><p>我们这时就可以实现一个 join 方法来解决这个问题。</p> <div class="language- extra-class"><pre class="language-text"><code>// 如果通过 isNothing 的检查，就返回自身的 value
MayBe.prototype.join = function () {
  return this.isNoting()? MayBe.of(null) : this.value
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let joinExample2 = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }

// 这个时候我们想让5加上4就很简单了。
joinExample2.join().map((value) =&gt; value + 4)
// =&gt; MayBe { value: 9 }
</code></pre></div><p>再延伸一下，我们扩展一个 chain 方法。</p> <div class="language- extra-class"><pre class="language-text"><code>MayBe.prototype.chain = function (fn) {
  return this.map(fn).join()
}
</code></pre></div><p>调用 chain 后就能把嵌套的 MayBe 展开了。</p> <div class="language- extra-class"><pre class="language-text"><code>let joinExample3 = MayBe.of(MayBe.of(5));
// =&gt; MayBe { value: MayBe { value: 5 } }


joinExample3.chain((insideMayBe) =&gt; {
  return insideMayBe.map((value) =&gt; value + 4)
})
// =&gt; MayBe { value: 9 }
</code></pre></div><p><strong>Monad</strong> 其实就是一个含有 chain 方法的函子。只有of 和 map 的 MayBe 是一个函子，含有 chain 的函子是一个 Monad。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <h3 id="javascript是函数式编程语言吗"><a href="#javascript是函数式编程语言吗" class="header-anchor">#</a> JavaScript是函数式编程语言吗？</h3> <p>函数式编程主张函数必须接受至少一个参数并返回一个值，但是JavaScript允许我们创建一个不接受参数并且实际上什么也不返回的函数。所以JavaScript不是一种纯函数语言，更像是一种多范式的语言，不过它非常适合函数式编程范式。</p> <p>JavaScript是一门多范型语言，或者也称为混合范型语言。JavaScript 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。</p> <h2 id="补充"><a href="#补充" class="header-anchor">#</a> 补充</h2> <h3 id="_1、纯函数是数学函数"><a href="#_1、纯函数是数学函数" class="header-anchor">#</a> 1、纯函数是数学函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function generateGetNumber() {
  let numberKeeper = {}
  return function (number) {
    return numberKeeper.hasOwnProperty(number) ?
    number :
    numberKeeper[number] = number + number
  }
}
const getNumber = generateGetNumber()
getNumber(1)
getNumber(2)
……
getNumber(9)
getNumber(10)

// 此时numberKeeper为：
{
  1: 2
  2: 4
  3: 6
  4: 8
  5: 10
  6: 12
  7: 14
  8: 16
  9: 18
  10: 20
}
</code></pre></div><p>现在我们规定，getNumber只接受1-10范围的参数，那么返回值肯定是 numberKeeper 中的某一个 value 。据此我们分析一下 getNumber ,该函数接受一个输入并为给定的范围（此处范围是10）映射输出。输入具有强制的、相应的输出，并且也不存在映射两个输出的输入。</p> <p>下面我来再看一下数学函数的定义（维基百科）</p> <blockquote><p>在数学中，函数是一种输入集合和可允许的输出集合之间的关系，具有如下属性：每个输入都精确地关联一个输出。函数的输入称为参数，输出称为值。对于一个给定的函数，所有被允许的输入集合称为该函数的定义域，而被允许的输出集合称为值域。</p></blockquote> <p>根据我们对于 getNumber 的分析，对照数学函数的定义，会发现完全一致。我们上面的getNumber函数的定义域是1-10，值域是2,4,6,……18,20</p> <h3 id="_2、实例"><a href="#_2、实例" class="header-anchor">#</a> 2、实例</h3> <p>文中所有的概念对应的实例可以在 <a href="https://github.com/qiqihaobenben/learning-functional" target="_blank" rel="noopener noreferrer">https://github.com/qiqihaobenben/learning-functional<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 获取，可以打开对应的注释来实际执行一下。</p> <h3 id="_3、荐书"><a href="#_3、荐书" class="header-anchor">#</a> 3、荐书</h3> <p><a href="https://book.douban.com/subject/30180100/" target="_blank" rel="noopener noreferrer">《JavaScript ES6 函数式编程入门经典》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>,强烈建议想入门函数式编程的同学看一下，书有点老，可以略过工具介绍之类的，关键看其内在的思想，最重要的是，这本书很薄，差不多跟一本漫画书类似。</p> <h3 id="_4、推荐文章-非引用文章"><a href="#_4、推荐文章-非引用文章" class="header-anchor">#</a> 4、推荐文章（非引用文章）</h3> <ol><li><a href="https://www.h5jun.com/post/js-functional-1.html" target="_blank" rel="noopener noreferrer">漫谈 JS 函数式编程（一）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.h5jun.com/post/parseInt-to-functional.html" target="_blank" rel="noopener noreferrer">从一道坑人的面试题说函数式编程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener noreferrer">函数式编程入门教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://yanhaijing.com/javascript/2018/03/01/functional-programming-practice/" target="_blank" rel="noopener noreferrer">函数式编程的一点实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/qiqihaobenben/Front-End-Basics/edit/master/docs/javascript/utility/fp.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/18/2021, 5:27:33 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/javascript/utility/data-interaction/cross-origin.html" class="prev">
        前端请求跨域
      </a></span> <span class="next"><a href="/javascript/utility/cache.html">
        三种本地存储方式和一些扩展
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.26ddf859.js" defer></script><script src="/assets/js/2.0a0a1bce.js" defer></script><script src="/assets/js/158.dd412e9f.js" defer></script>
  </body>
</html>
