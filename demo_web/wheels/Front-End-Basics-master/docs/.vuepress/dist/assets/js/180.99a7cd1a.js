(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{659:function(e,t,s){"use strict";s.r(t);var o=s(45),r=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"nodejs-备忘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-备忘"}},[e._v("#")]),e._v(" NodeJS 备忘")]),e._v(" "),s("h2",{attrs:{id:"nodejs-事件循环"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-事件循环"}},[e._v("#")]),e._v(" NodeJS 事件循环")]),e._v(" "),s("p",[e._v("先精读一下这个"),s("a",{attrs:{href:"https://juejin.cn/post/6844904100195205133",target:"_blank",rel:"noopener noreferrer"}},[e._v("setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop"),s("OutboundLink")],1)]),e._v(" "),s("p",[e._v("事件循环通俗来说就是一个无限的 while 循环。")]),e._v(" "),s("p",[e._v("Node.js 事件循环的发起点（即执行完一个完整的事件循环）有五个：")]),e._v(" "),s("ul",[s("li",[e._v("Node.js 启动后；")]),e._v(" "),s("li",[e._v("setTimeout 回调函数；")]),e._v(" "),s("li",[e._v("setInterval 回调函数；")]),e._v(" "),s("li",[e._v("setImmediate 回到函数；")]),e._v(" "),s("li",[e._v("I/O 后的回调函数；（异步 I/O 又分为网络 I/O 和文件 I/O）")])]),e._v(" "),s("p",[e._v("可以看出以上都是宏任务，即每次事件循环都是开始于一次宏任务。")]),e._v(" "),s("h3",{attrs:{id:"宏任务和微任务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[e._v("#")]),e._v(" 宏任务和微任务")]),e._v(" "),s("p",[e._v("宏任务：在 Node.js 中宏任务包含 5 种——Node.js 启动主线程执行、 setTimeout、 setInterval、 setImmediate 和 I/O。宏任务到底谁先执行，还得看下次时间循环之前谁准备好了，setTimeout、 setInterval 和 I/O 都是耗时操作，setImmediate 是在主线程执行完所有代码后执行，其实就是插空执行。所以到底哪个宏任务先执行就需要看 Node.js 事件循环的 6 个流程其中的：timers（对应 setTimeout 和 setInterval）、poll（对应 I/O 及其他几乎所有回调函数）、check（对应 setImmediate） 这个几个阶段是否有准备就绪的回调任务。")]),e._v(" "),s("p",[e._v("微任务：在 Node.js 中微任务包含 2 种——process.nextTick 和 Promise。微任务在事件循环中优先级是最高的，因此如果事件循环中有微任务，会先把微任务队列清空。并且无论加入队列的顺序如何 process.nextTick 的优先级比 Promise 高。")]),e._v(" "),s("p",[e._v("主线程除了是一次宏任务之外，还要执行每次事件循环遍历所有任务，每次事件循环包含一个宏任务外加清空微任务队列，即使是在执行微任务队列中的某个任务时，又往微任务队列中添加了微任务，这个微任务也是需要在此次事件循环中执行的。")]),e._v(" "),s("p",[e._v("主线程是单线程的，但是 Node.js 是多线程执行，Node.js 还包括其他例如定时器触发线程、异步 I/O 事件线程、垃圾回收线程等。")]),e._v(" "),s("h2",{attrs:{id:"node-js-应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js-应用场景"}},[e._v("#")]),e._v(" Node.js 应用场景")]),e._v(" "),s("p",[e._v("Node.js 异步非阻塞的特性，适合网络 I/O 较多，并发高，但是 CPU 计算较少，业务复杂度高和业务迭代快的服务，或者一些通用性服务，所以 Node.js 适合应用在业务网关、中台服务及运营系统等。不适合"),s("strong",[e._v("大内存")]),e._v("和 "),s("strong",[e._v("CPU 密集")]),e._v("的场景。")])])}),[],!1,null,null,null);t.default=r.exports}}]);