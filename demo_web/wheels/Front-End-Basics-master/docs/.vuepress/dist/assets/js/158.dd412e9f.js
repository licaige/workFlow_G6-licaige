(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{633:function(a,e,t){"use strict";t.r(e);var n=t(45),r=Object(n.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"函数式编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[a._v("#")]),a._v(" 函数式编程")]),a._v(" "),t("h3",{attrs:{id:"什么是函数式编程-为何它重要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是函数式编程-为何它重要"}},[a._v("#")]),a._v(" 什么是函数式编程？为何它重要？")]),a._v(" "),t("h4",{attrs:{id:"数学中的函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数学中的函数"}},[a._v("#")]),a._v(" 数学中的函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("f(x) = y\n// 一个函数f，以x为参数，并返回输出y\n")])])]),t("p",[a._v("关键点：")]),a._v(" "),t("ul",[t("li",[a._v("函数必须总是接受一个参数")]),a._v(" "),t("li",[a._v("函数必须总是返回一个值")]),a._v(" "),t("li",[a._v("函数应该依据接收到的参数（例如x）而不是外部环境运行")]),a._v(" "),t("li",[a._v("对于一个给定的x，只会输出唯一的一个y")])]),a._v(" "),t("p",[a._v("函数式编程技术主要基于数学函数和它的思想，所以要理解函数式编程，先了解数学函数是有必要的。")]),a._v(" "),t("h3",{attrs:{id:"函数式编程的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程的定义"}},[a._v("#")]),a._v(" 函数式编程的定义")]),a._v(" "),t("p",[t("strong",[a._v("函数")]),a._v("是一段可以通过其名称被调用的代码。它可以接受参数，并返回值。")]),a._v(" "),t("p",[a._v("与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）一样，函数式编程（Functional programming）也是一种编程范式。我们能够以此创建仅依赖输入就可以完成自身逻辑的函数。这保证了当函数被多次调用时仍然返回相同的结果（引用透明性）。函数不会改变任何外部环境的变量，这将产生可缓存的，可测试的代码库。")]),a._v(" "),t("h3",{attrs:{id:"函数式编程具有以下特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程具有以下特征"}},[a._v("#")]),a._v(" 函数式编程具有以下特征")]),a._v(" "),t("h4",{attrs:{id:"_1、引用透明性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、引用透明性"}},[a._v("#")]),a._v(" 1、引用透明性")]),a._v(" "),t("p",[a._v("所有的函数对于相同的输入都将返回相同的值，函数的这一属性被称为"),t("strong",[a._v("引用透明性（Referential Transparency）")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 引用透明的例子，函数identity无论输入什么，都会原封不动的返回\nvar identity = (i) => {return i}\n")])])]),t("h5",{attrs:{id:"替换模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#替换模型"}},[a._v("#")]),a._v(" 替换模型")]),a._v(" "),t("p",[a._v("把一个引用透明的函数用于其他函数调用之间。")]),a._v(" "),t("p",[t("code",[a._v("sum(4,5) + identity(1)")])]),a._v(" "),t("p",[a._v("根据引用透明的定义，我们可以把上面的语句换成：")]),a._v(" "),t("p",[t("code",[a._v("sum(4,5) + 1")])]),a._v(" "),t("p",[a._v("该过程被称为替换模型（Substitution Model）,因为函数的逻辑不依赖其他全局变量，你可以直接替换函数的结果，这与它的值是一样的。所以，这使得"),t("strong",[a._v("并发代码")]),a._v("和"),t("strong",[a._v("缓存")]),a._v("成为可能。")]),a._v(" "),t("p",[t("strong",[a._v("并发代码：")]),a._v(" 并发运行的时候，如果依赖了全局数据，要保证数据一致，必须同步，而且必要时需要锁机制。遵循引用透明的函数只依赖参数的输入，所以可以自由的运行。")]),a._v(" "),t("p",[t("strong",[a._v("缓存：")]),a._v(" 由于函数会为给定的输入返回相同的值，实际上我们就能缓存它了。比如实现一个计算给定数值的阶乘的函数，我们就可以把每次阶乘的结果缓存下来，下一次直接用，就不用计算了。比如第一次输入5，结果是120，第二次输入5，我们知道结果必然是120，所以就可以返回已缓存的值，而不必再计算一次。")]),a._v(" "),t("h4",{attrs:{id:"_2、声明式和抽象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、声明式和抽象"}},[a._v("#")]),a._v(" 2、声明式和抽象")]),a._v(" "),t("p",[a._v("函数式编程主张声明式编程和编写抽象的代码。")]),a._v(" "),t("h5",{attrs:{id:"比较命令式和声明式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#比较命令式和声明式"}},[a._v("#")]),a._v(" 比较命令式和声明式")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 有一个数组，要遍历它并把它打印到控制台\n\n/*命令式*/\nvar array = [1,2,3]\nfor(var i = 0; i < array.length; i++)\nconsole(array[i]) // 打印 1,2,3\n\n// 命令式编程中，我们精确的告诉程序应该“如何”做：获取数组的长度，通过数组的长度循环数组，在每一次循环中用索引获取每一个数组元素，然后打印出来。\n// 但是我们的任务只是打印出数组的元素。并不是要告诉编译器要如何实现一个遍历。\n\n\n\n/*声明式*/\nvar array = [1,2,3]\narray.forEach((element) => console.log(element)) // 打印 1,2,3\n\n// 我们使用了一个处理“如何”做的抽象函数，然后我们就能只关心做“什么”了\n")])])]),t("h5",{attrs:{id:"函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程主张以抽象的方式创建函数-例如上文的foreach-这些函数能够在代码的其他部分被重用。"}},[a._v("#")]),a._v(" 函数式编程主张以抽象的方式创建函数，例如上文的forEach，这些函数能够在代码的其他部分被重用。")]),a._v(" "),t("h4",{attrs:{id:"_3、纯函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、纯函数"}},[a._v("#")]),a._v(" 3、纯函数")]),a._v(" "),t("p",[a._v("大多数函数式编程的好处来自于编写纯函数，"),t("strong",[a._v("纯函数")]),a._v("是对给定的输入返回相同的输出的函数，并且纯函数不应依赖任何外部变量，也不应改变任何外部变量。")]),a._v(" "),t("h5",{attrs:{id:"纯函数的好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#纯函数的好处"}},[a._v("#")]),a._v(" 纯函数的好处")]),a._v(" "),t("ol",[t("li",[a._v("纯函数产生容易测试的代码")]),a._v(" "),t("li",[a._v("纯函数容易写出合理的代码")]),a._v(" "),t("li",[a._v("纯函数容易写出并发代码\n纯函数总是允许我们并发的执行代码。因为纯函数不会改变它的环境，这意味着我们根本不需要担心同步问题。")]),a._v(" "),t("li",[a._v("纯函数的输出结果可缓存\n既然纯函数总是为给定的输入返回相同的输出，那么我们就能够缓存函数的输出。")])]),a._v(" "),t("h2",{attrs:{id:"高阶函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数"}},[a._v("#")]),a._v(" 高阶函数")]),a._v(" "),t("h3",{attrs:{id:"数据和数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据和数据类型"}},[a._v("#")]),a._v(" 数据和数据类型")]),a._v(" "),t("p",[a._v("程序作用于数据，数据对于程序的执行很重要。每种编程语言都有数据类型。这些数据类型能够存储数据并允许程序作用其中。")]),a._v(" "),t("h3",{attrs:{id:"javascript中函数是一等公民-first-class-citizens"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript中函数是一等公民-first-class-citizens"}},[a._v("#")]),a._v(" JavaScript中函数是一等公民(First Class Citizens)")]),a._v(" "),t("p",[a._v("**当一门语言允许函数作为任何其他数据类型使用时，函数被称为一等公民。**也就是说函数可被赋值给变量，作为参数传递，也可被其他函数返回。")]),a._v(" "),t("p",[a._v("函数作为JavaScript的一种数据类型，由于函数是类似String的数据类型，所以我们能把函数存入一个变量，能够作为函数的参数进行传递。所以JavaScript中函数是一等公民。")]),a._v(" "),t("h3",{attrs:{id:"高阶函数的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数的定义"}},[a._v("#")]),a._v(" 高阶函数的定义")]),a._v(" "),t("p",[a._v("接受另一个函数作为其参数的函数称为高阶函数(Higher-Order-Function)，或者说高阶函数是接受函数作为参数并且/或者返回函数作为输出的函数。")]),a._v(" "),t("h3",{attrs:{id:"抽象和高阶函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象和高阶函数"}},[a._v("#")]),a._v(" 抽象和高阶函数")]),a._v(" "),t("p",[a._v("一般而言，高阶函数通常用于抽象通用的问题，换句话说，高阶函数就是定义抽象。")]),a._v(" "),t("p",[t("strong",[a._v("抽象")]),a._v(" ： 在软件工程和计算机科学中，抽象是一种管理计算机系统复杂性的技术。 通过建立一个人与系统进行交互的复杂程度，把更复杂的细节抑制在当前水平之下。简言之，抽象让我们专注于预定的目标而无须关心底层的系统概念。")]),a._v(" "),t("blockquote",[t("p",[a._v("例如：你在编写一个涉及数值操作的代码，你不会对底层硬件的数字表现方式到底是16位还是32位整数有很深的了解，包括这些细节在哪里屏蔽。因为它们被抽象出来了，只留下了简单的数字给我们使用。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 用forEach抽象出遍历数组的操作\nconst forEach = (array,fn) => {\n  let i;\n  for(i=0;i<array.length;i++) {\n    fn(array[i])\n  }\n}\n\n// 用户不需要理解forEach是如何实现遍历的，如此问题就被抽象出来了。\n//例如，想要打印出数组的每一项\nlet array = [1,2,3]\nforEach(array,(data) => console.log(data))\n")])])]),t("h3",{attrs:{id:"闭包和高阶函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#闭包和高阶函数"}},[a._v("#")]),a._v(" 闭包和高阶函数")]),a._v(" "),t("p",[a._v("什么是闭包？简言之，**闭包就是一个内部函数。**什么是内部函数？就是在另一个函数内部的函数。")]),a._v(" "),t("p",[a._v("闭包的强大之处在于它对作用域链（或作用域层级）的访问。从技术上讲，闭包有3个可访问的作用域。")]),a._v(" "),t("p",[a._v("(1) 在它自身声明之内声明的变量")]),a._v(" "),t("p",[a._v("(2) 对全局变量的访问")]),a._v(" "),t("p",[a._v("(3) 对外部函数变量的访问（关键点）")]),a._v(" "),t("p",[t("strong",[a._v("实例一")]),a._v("：假设你再遍历一个来自服务器的数组，并发现数据错了。你想调试一下，看看数组里面究竟包含了什么。不要用命令式的方法，要用函数式的方法来实现。这里就需要一个 tap 函数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const tap = (value) => {\n  return (fn) => {\n    typeof fn === 'function' && fn(value)\n    console.log(value)\n  }\n}\n\n// 没有调试之前\nforEach(array, data => {\n  console.log(data + data)\n})\n\n// 在 forEach 中使用 tap 调试\nforEach(array, data => {\n  tap(data)(() => {\n    console.log(data + data)\n  })\n})\n")])])]),t("p",[a._v("完成一个简单的reduce函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const reduce = (array,fn,initialValue) => {\n  let accumulator;\n  if(initialValue != undefined)\n    accumulator = initialValue\n  else\n    accumulator = array[0]\n\n  if(initialValue === undefined)\n    for(let i = 1; i < array.length; i++)\n      accumulator = fn(accumulator, array[i])\n  else\n    for(let value of array)\n      accumulator = fn(accumulator,value)\n  return accumulator\n}\n\nconsole.log(reduce([1,2,3], (accumulator,value) => accumulator + value))\n// 打印出6\n")])])]),t("h2",{attrs:{id:"柯里化与偏应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柯里化与偏应用"}},[a._v("#")]),a._v(" 柯里化与偏应用")]),a._v(" "),t("h3",{attrs:{id:"一些概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一些概念"}},[a._v("#")]),a._v(" 一些概念")]),a._v(" "),t("h4",{attrs:{id:"一元函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一元函数"}},[a._v("#")]),a._v(" 一元函数")]),a._v(" "),t("p",[a._v("只接受一个参数的函数称为一元(unary)函数。")]),a._v(" "),t("h4",{attrs:{id:"二元函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二元函数"}},[a._v("#")]),a._v(" 二元函数")]),a._v(" "),t("p",[a._v("只接受两个参数的函数称为二元(binary)函数。")]),a._v(" "),t("h4",{attrs:{id:"变参函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变参函数"}},[a._v("#")]),a._v(" 变参函数")]),a._v(" "),t("p",[a._v("变参函数是接受可变数量的函数。")]),a._v(" "),t("h3",{attrs:{id:"柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[a._v("#")]),a._v(" 柯里化")]),a._v(" "),t("p",[a._v("柯里化是把一个多参数函数转换为一个嵌套的一元函数的过程。")]),a._v(" "),t("p",[a._v("例如")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 一个多参数函数\nconst add = (x,y) => x + y;\nadd(2,3)\n\n// 一个嵌套的一元函数\nconst addCurried = x => y => x + y;\naddCurried(2)(3)\n\n// 然后我们写一个高阶函数，把 add 转换成 addCurried 的形式。\nconst curry = (binaryFn) => {\n  return function (firstArg) {\n    return function (secondArg) {\n      return binaryFn(firstArg,secondArg)\n    }\n  }\n}\nlet autoCurriedAdd = carry(add)\nautoCurriedAdd(2)(3)\n")])])]),t("p",[a._v("上面只是简单实现了一个二元函数的柯里化，下面我们要实现一个更多参数的函数的柯里化。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const curry = (fn) => {\n  if (typeof fn !== 'function') {\n    throw Error('No function provided')\n  }\n  return function curriedFn (...args) {\n    // 判断当前接受的参数是不是小于进行柯里化的函数的参数个数\n    if(args.length < fn.length) {\n      // 如果小于的话就返回一个函数再去接收剩下的参数\n      return function (...argsOther) {\n        return curriedFn.apply(null, args.concat(argsOther))\n      }\n    }else {\n      return fn.apply(null,args)\n    }\n  }\n}\n\n const multiply = (x,y,z) => x * y * z;\n console.log(curry(multiply)(2)(3)(4))\n")])])]),t("p",[a._v("柯里化的应用实例：从数组中找出含有数字的元素")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let match = curry(function (expr,str) {\n  return str.match(expr)\n})\nlet hasNumber = match(/[0-9]+/)\n\nlet initFilter = curry(function (fn,array) {\n  return array.filter(fn)\n})\n\nlet findNumberInArray = initFilter(hasNumber)\nconsole.log(findNumberInArray(['aaa', 'bb2', '33c', 'ddd', ]))\n// 打印 [ 'bb2', '33c' ]\n")])])]),t("h3",{attrs:{id:"偏应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#偏应用"}},[a._v("#")]),a._v(" 偏应用")]),a._v(" "),t("p",[a._v("我们上面设计的柯里化函数总是在最后接受一个数组，这使得它能接受的参数列表只能是从最左到最右。")]),a._v(" "),t("p",[a._v("但是有时候，我们不能按照从左到右的这样严格传入参数，或者只是想部分地应用函数参数。这里我们就需要用到偏应用这个概念，它允许开发者部分地应用函数参数。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const partial = function (fn, ...partialArgs) {\n  return function (...fullArguments) {\n    let args = partialArgs\n    let arg = 0;\n    for(let i = 0; i < args.length && arg < fullArguments.length; i++) {\n      if(args[i] === undefined) {\n        args[i] = fullArguments[arg++]\n      }\n    }\n    return fn.apply(null,args)\n  }\n}\n")])])]),t("p",[a._v("偏应用的示例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('// 打印某个格式化的JSON\nlet prettyPrintJson = partial(JSON.stringify,undefined,null,2)\nconsole.log(prettyPrintJson({name:\'fangxu\',gender:\'male\'}))\n\n// 打印出\n{\n  "name": "fangxu",\n  "gender": "male"\n}\n')])])]),t("h2",{attrs:{id:"组合与管道"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合与管道"}},[a._v("#")]),a._v(" 组合与管道")]),a._v(" "),t("h3",{attrs:{id:"unix的理念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#unix的理念"}},[a._v("#")]),a._v(" Unix的理念")]),a._v(" "),t("ol",[t("li",[a._v("每个程序只做好一件事情，为了完成一项新的任务，重新构建要好于在复杂的旧程序中添加新“属性”。")]),a._v(" "),t("li",[a._v("每个程序的输出应该是另一个尚未可知的程序的输入。")]),a._v(" "),t("li",[a._v("每一个基础函数都需要接受一个参数并返回数据。")])]),a._v(" "),t("h3",{attrs:{id:"组合-compose"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合-compose"}},[a._v("#")]),a._v(" 组合(compose)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const compose = (...fns) => {\n  return (value) => reduce(fns.reverse(),(acc,fn) => fn(acc), value)\n}\n")])])]),t("p",[a._v("compose 组合的函数，是按照传入的顺序从右到左调用的。所以传入的 fns 要先 reverse 一下，然后我们用到了reduce ，reduce 的累加器初始值是 value ，然后会调用 "),t("code",[a._v("(acc,fn) => fn(acc)")]),a._v(", 依次从 fns 数组中取出 fn ，将累加器的当前值传入 fn ，即把上一个函数的返回值传递到下一个函数的参数中。")]),a._v(" "),t("p",[a._v("组合的实例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let splitIntoSpace = (str) => str.split(' ')\nlet count = (array) => array.length\nconst countWords = composeN(count, splitIntoSpace)\nconsole.log(countWords('make smaller or less in amount'))\n// 打印 6\n")])])]),t("h3",{attrs:{id:"管道-序列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管道-序列"}},[a._v("#")]),a._v(" 管道/序列")]),a._v(" "),t("p",[a._v("compose 函数的数据流是从右往左的，最右侧的先执行。当然，我们还可以让最左侧的函数先执行，最右侧的函数最后执行。这种从左至右处理数据流的过程称为管道（pipeline）或序列(sequence)。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 跟compose的区别，只是没有调用fns.reverse()\nconst pipe = (...fns) => (value) => reduce(fns,(acc,fn) => fn(acc),value)\n")])])]),t("h2",{attrs:{id:"函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函子"}},[a._v("#")]),a._v(" 函子")]),a._v(" "),t("h3",{attrs:{id:"什么是函子-functor"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是函子-functor"}},[a._v("#")]),a._v(" 什么是函子(Functor)？")]),a._v(" "),t("p",[t("strong",[a._v("定义")]),a._v("：函子是一个普通对象（在其它语言中，可能是一个类），它实现了map函数，在遍历每个对象值的时候生成一个新对象。")]),a._v(" "),t("h4",{attrs:{id:"实现一个函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现一个函子"}},[a._v("#")]),a._v(" 实现一个函子")]),a._v(" "),t("p",[a._v("1、简言之，函子是一个持有值的容器。而且函子是一个普通对象。我们就可以创建一个容器（也就是对象），让它能够持有任何传给它的值。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const Container = function (value) {\n  this.value = value\n}\n\nlet testValue = new Container(1)\n// => Container {value:1}\n")])])]),t("p",[a._v("我们给 Container 增加一个静态方法，它可以为我们在创建新的 Containers 时省略 new 关键字。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Container.of = function (value) {\n  return new Container(value)\n}\n\n// 现在我们就可以这样来创建\nContainer.of(1)\n// => Container {value:1}\n")])])]),t("p",[a._v("2、函子需要实现 map 方法，具体的实现是，map 函数从 Container 中取出值，传入的函数把取出的值作为参数调用，并将结果放回 Container。")]),a._v(" "),t("blockquote",[t("p",[a._v("为什么需要 map 函数，我们上面实现的 Container 仅仅是持有了传给它的值。但是持有值的行为几乎没有任何应用场景，而 map 函数发挥的作用就是，允许我们使用当前 Container 持有的值调用任何函数。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Container.prototype.map = function (fn) {\n  return Container.of(fn(this.value))\n}\n\n// 然后我们实现一个数字的 double 操作\nlet double = (x) => x + x;\nContainer.of(3).map(double)\n// => Container {value: 6}\n")])])]),t("p",[a._v("3、map返回了一传入函数的执行结果为值的 Container 实例，所以我们可以链式操作。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Container.of(3).map(double).map(double).map(double)\n// => Container {value: 24}\n")])])]),t("p",[t("strong",[a._v("通过以上的实现，我们可以发现，函子就是一个实现了map契约的对象。函子是一个寻求契约的概念，该契约很简单，就是实现 map 。根据实现 map 函数的方式不同，会产生不同类型的函子，如 MayBe 、 Either")])]),a._v(" "),t("p",[a._v("函子可以用来做什么？之前我们用tap函数来函数式的解决代码报错的调试问题，如何更加函数式的处理代码中的问题，那就需要用到下面我们说的MayBe函子")]),a._v(" "),t("h3",{attrs:{id:"maybe-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#maybe-函子"}},[a._v("#")]),a._v(" MayBe 函子")]),a._v(" "),t("p",[a._v("让我们先写一个upperCase函数来假设一种场景")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let value = 'string';\nfunction upperCase(value) {\n  // 为了避免报错，我们得写这么一个判断\n  if(value != null || value != undefined)\n    return value.toUpperCase()\n}\nupperCase(value)\n// => STRING\n")])])]),t("p",[a._v("如上面所示，我们代码中经常需要判断一些"),t("code",[a._v("null")]),a._v("和"),t("code",[a._v("undefined")]),a._v("的情况。下面我们来看一下MayBe函子的实现。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// MayBe 跟上面的 Container 很相似\nexport const MayBe = function (value) {\n  this.value = value\n}\nMayBe.of = function (value) {\n  return new MayBe(value)\n}\n// 多了一个isNothing\nMayBe.prototype.isNoting = function () {\n  return this.value === null || this.value === undefined;\n}\n// 函子必定有 map,但是 map 的实现方式可能不同\nMayBe.prototype.map = function(fn) {\n  return this.isNoting()?MayBe.of(null):MayBe.of(fn(this.value))\n}\n\n// MayBe应用\nlet value = 'string';\nMayBe.of(value).map(upperCase)\n// => MayBe { value: 'STRING' }\nlet nullValue = null\nMayBe.of(nullValue).map(upperCase)\n// 不会报错 MayBe { value: null }\n")])])]),t("h3",{attrs:{id:"either-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#either-函子"}},[a._v("#")]),a._v(" Either 函子")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('MayBe.of("tony")\n  .map(() => undefined)\n  .map((x)f => "Mr. " + x)\n')])])]),t("p",[a._v("上面的代码结果是 "),t("code",[a._v("MyaBe {value: null}")]),a._v(",这只是一个简单的例子，我们可以想一下，如果代码比较复杂，我们是不知道到底是哪一个分支在检查 undefined 和 null 值时执行失败了。这时候我们就需要 Either 函子了，它能解决分支拓展问题。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const Nothing = function (value) {\n  this.value = value;\n}\nNothing.of = function (value) {\n  return new Nothing(value)\n}\nNothing.prototype.map = function (fn) {\n  return this;\n}\nconst Some = function (value) {\n  this.value = value;\n}\nSome.of = function (value) {\n  return new Some(value)\n}\nSome.prototype.map = function (fn) {\n  return Some.of(fn(this.value));\n}\n\nconst Either = {\n  Some,\n  Nothing\n}\n\n")])])]),t("h3",{attrs:{id:"pointed-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pointed-函子"}},[a._v("#")]),a._v(" Pointed 函子")]),a._v(" "),t("p",[a._v("函子只是一个实现了 map 契约的接口。Pointed 函子也是一个函子的子集，它具有实现了 of 契约的接口。 我们在 MayBe 和 Either 中也实现了 of 方法，用来在创建 Container 时不使用 new 关键字。所以 MayBe 和 Either 都可称为 Pointed 函子。")]),a._v(" "),t("blockquote",[t("p",[a._v("ES6 增加了 Array.of， 这使得数组成为了一个 Pointed 函子。")])]),a._v(" "),t("h3",{attrs:{id:"monad-函子"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#monad-函子"}},[a._v("#")]),a._v(" Monad 函子")]),a._v(" "),t("p",[a._v("MayBe 函子很可能会出现嵌套，如果出现嵌套后，我们想要继续操作真正的value是有困难的。必须深入到 MayBe 内部进行操作。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let joinExample = MayBe.of(MayBe.of(5));\n// => MayBe { value: MayBe { value: 5 } }\n\n// 这个时候我们想让5加上4，需要深入 MayBe 函子内部\njoinExample.map((insideMayBe) => {\n  return insideMayBe.map((value) => value + 4)\n})\n// => MayBe { value: MayBe { value: 9 } }\n")])])]),t("p",[a._v("我们这时就可以实现一个 join 方法来解决这个问题。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// 如果通过 isNothing 的检查，就返回自身的 value\nMayBe.prototype.join = function () {\n  return this.isNoting()? MayBe.of(null) : this.value\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let joinExample2 = MayBe.of(MayBe.of(5));\n// => MayBe { value: MayBe { value: 5 } }\n\n// 这个时候我们想让5加上4就很简单了。\njoinExample2.join().map((value) => value + 4)\n// => MayBe { value: 9 }\n")])])]),t("p",[a._v("再延伸一下，我们扩展一个 chain 方法。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("MayBe.prototype.chain = function (fn) {\n  return this.map(fn).join()\n}\n")])])]),t("p",[a._v("调用 chain 后就能把嵌套的 MayBe 展开了。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let joinExample3 = MayBe.of(MayBe.of(5));\n// => MayBe { value: MayBe { value: 5 } }\n\n\njoinExample3.chain((insideMayBe) => {\n  return insideMayBe.map((value) => value + 4)\n})\n// => MayBe { value: 9 }\n")])])]),t("p",[t("strong",[a._v("Monad")]),a._v(" 其实就是一个含有 chain 方法的函子。只有of 和 map 的 MayBe 是一个函子，含有 chain 的函子是一个 Monad。")]),a._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),t("h3",{attrs:{id:"javascript是函数式编程语言吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript是函数式编程语言吗"}},[a._v("#")]),a._v(" JavaScript是函数式编程语言吗？")]),a._v(" "),t("p",[a._v("函数式编程主张函数必须接受至少一个参数并返回一个值，但是JavaScript允许我们创建一个不接受参数并且实际上什么也不返回的函数。所以JavaScript不是一种纯函数语言，更像是一种多范式的语言，不过它非常适合函数式编程范式。")]),a._v(" "),t("p",[a._v("JavaScript是一门多范型语言，或者也称为混合范型语言。JavaScript 的简单来自于此，复杂也来自于此；生存能力来自于此，抨击诟病也来自于此。")]),a._v(" "),t("h2",{attrs:{id:"补充"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[a._v("#")]),a._v(" 补充")]),a._v(" "),t("h3",{attrs:{id:"_1、纯函数是数学函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、纯函数是数学函数"}},[a._v("#")]),a._v(" 1、纯函数是数学函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function generateGetNumber() {\n  let numberKeeper = {}\n  return function (number) {\n    return numberKeeper.hasOwnProperty(number) ?\n    number :\n    numberKeeper[number] = number + number\n  }\n}\nconst getNumber = generateGetNumber()\ngetNumber(1)\ngetNumber(2)\n……\ngetNumber(9)\ngetNumber(10)\n\n// 此时numberKeeper为：\n{\n  1: 2\n  2: 4\n  3: 6\n  4: 8\n  5: 10\n  6: 12\n  7: 14\n  8: 16\n  9: 18\n  10: 20\n}\n")])])]),t("p",[a._v("现在我们规定，getNumber只接受1-10范围的参数，那么返回值肯定是 numberKeeper 中的某一个 value 。据此我们分析一下 getNumber ,该函数接受一个输入并为给定的范围（此处范围是10）映射输出。输入具有强制的、相应的输出，并且也不存在映射两个输出的输入。")]),a._v(" "),t("p",[a._v("下面我来再看一下数学函数的定义（维基百科）")]),a._v(" "),t("blockquote",[t("p",[a._v("在数学中，函数是一种输入集合和可允许的输出集合之间的关系，具有如下属性：每个输入都精确地关联一个输出。函数的输入称为参数，输出称为值。对于一个给定的函数，所有被允许的输入集合称为该函数的定义域，而被允许的输出集合称为值域。")])]),a._v(" "),t("p",[a._v("根据我们对于 getNumber 的分析，对照数学函数的定义，会发现完全一致。我们上面的getNumber函数的定义域是1-10，值域是2,4,6,……18,20")]),a._v(" "),t("h3",{attrs:{id:"_2、实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、实例"}},[a._v("#")]),a._v(" 2、实例")]),a._v(" "),t("p",[a._v("文中所有的概念对应的实例可以在 "),t("a",{attrs:{href:"https://github.com/qiqihaobenben/learning-functional",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://github.com/qiqihaobenben/learning-functional"),t("OutboundLink")],1),a._v(" 获取，可以打开对应的注释来实际执行一下。")]),a._v(" "),t("h3",{attrs:{id:"_3、荐书"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、荐书"}},[a._v("#")]),a._v(" 3、荐书")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://book.douban.com/subject/30180100/",target:"_blank",rel:"noopener noreferrer"}},[a._v("《JavaScript ES6 函数式编程入门经典》"),t("OutboundLink")],1),a._v(",强烈建议想入门函数式编程的同学看一下，书有点老，可以略过工具介绍之类的，关键看其内在的思想，最重要的是，这本书很薄，差不多跟一本漫画书类似。")]),a._v(" "),t("h3",{attrs:{id:"_4、推荐文章-非引用文章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、推荐文章-非引用文章"}},[a._v("#")]),a._v(" 4、推荐文章（非引用文章）")]),a._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://www.h5jun.com/post/js-functional-1.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("漫谈 JS 函数式编程（一）"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://www.h5jun.com/post/parseInt-to-functional.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("从一道坑人的面试题说函数式编程"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("函数式编程入门教程"),t("OutboundLink")],1)]),a._v(" "),t("li",[t("a",{attrs:{href:"https://yanhaijing.com/javascript/2018/03/01/functional-programming-practice/",target:"_blank",rel:"noopener noreferrer"}},[a._v("函数式编程的一点实战"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=r.exports}}]);