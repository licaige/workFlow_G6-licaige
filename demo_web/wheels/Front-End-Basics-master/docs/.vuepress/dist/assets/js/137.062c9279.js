(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{603:function(e,t,v){"use strict";v.r(t);var _=v(45),a=Object(_.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"set-、-map-和垃圾回收"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set-、-map-和垃圾回收"}},[e._v("#")]),e._v(" Set 、 Map 和垃圾回收")]),e._v(" "),v("h2",{attrs:{id:"set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" Set")]),e._v(" "),v("p",[e._v("Set 类型是一种"),v("strong",[e._v("有序列表")]),e._v("，其中含有一些"),v("strong",[e._v("相互独立")]),e._v("的"),v("strong",[e._v("非重复值")]),e._v("，通过 Set 集合可以快速访问其中的数据，更有效地追踪各种离散值。")]),e._v(" "),v("p",[e._v('在 Set 集合中，不会对所存值进行强制类型转换，数字 5 和字符串 "5" 可以作为两个独立元素存在（引擎内部使用 '),v("code",[e._v("Object.is()")]),e._v(" 方法检测两个值是否一致，唯一的例外是，Set 集合中的 +0 和 -0 被认为是相等的），当然，如果向 Set 集合中添加多个对象，则它们之间彼此保持独立。")]),e._v(" "),v("h3",{attrs:{id:"set-的一些特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#set-的一些特性"}},[e._v("#")]),e._v(" Set 的一些特性")]),e._v(" "),v("ul",[v("li",[e._v("Set 的方法和属性包括："),v("code",[e._v("add()")]),e._v(" "),v("code",[e._v("delete()")]),e._v(" "),v("code",[e._v("clear()")]),e._v(" "),v("code",[e._v("has()")]),e._v(" "),v("code",[e._v("keys()")]),e._v(" "),v("code",[e._v("values()")]),e._v(" "),v("code",[e._v("entries()")]),e._v(" "),v("code",[e._v("forEach()")]),e._v(" "),v("code",[e._v("size")]),e._v("属性，"),v("code",[e._v("keys()")]),e._v(" "),v("code",[e._v("values()")]),e._v(" "),v("code",[e._v("entries()")]),e._v(" 返回的都是一个迭代器对象")]),e._v(" "),v("li",[e._v("如果多次调用 "),v("code",[e._v("add()")]),e._v(" 方法并传入相同的值作为参数，那么后续的调用实际上会被忽略。")]),e._v(" "),v("li",[e._v("Set 构造函数可以接受所有可迭代对象作为参数，数组、Set 集合、Map 集合，DOM 中的 NodeList 对象、String 对象，函数的 arguments 属性，都是可迭代的，因而都可以作为 Set 构造函数的参数使用；构造函数通过迭代器从参数中提取值。")]),e._v(" "),v("li",[e._v("通过 "),v("code",[e._v("has()")]),e._v(" 方法可以检测 Set 集合中是否存在某个值。之前在对象中都是读取对象的值来判断属性是否存在，但是在 JavaScript 中有一个 "),v("code",[e._v("in")]),e._v(" 运算符，其不需要读取对象的值就可以判断属性在对象中是否存在，如果存在就返回 true。但是 "),v("code",[e._v("in")]),e._v(" 运算符也会检索对象的原型，只有当对象原型为 "),v("code",[e._v("null")]),e._v(" 时使用这个方法才比较稳妥。即便是这样，也建议使用 "),v("code",[e._v("in")]),e._v(" 运算符，不过实际开发中许多开发者仍然使用访问属性的方法进行判断，并没有使用 in 运算符。")]),e._v(" "),v("li",[e._v("Set 集合的 "),v("code",[e._v("forEach()")]),e._v(" 方法比较特别，"),v("strong",[e._v("回调函数的前两个参数的值竟然是一样的")]),e._v("。尽管这看起来像是一个错误，不过也解释的通。数组和 Map 集合的 "),v("code",[e._v("forEach()")]),e._v(" 的回调函数都接受 3 个参数，"),v("strong",[e._v("前两个分别是值和键名（对于数组来说就是数值型索引值）")]),e._v("，然而 Set 集合没有键名，ECMAScript 6 标准制定委员会本可以规定 Set 集合的 "),v("code",[e._v("forEach()")]),e._v(" 的回调函数只接受两个参数，但这可能导致几个方法之间分歧过大，于是他们最终决定所有函数都接受 3 个参数：Set 集合中的每个元素也按照键名和值的形式存储，从而才能保证在所有 "),v("code",[e._v("forEach()")]),e._v(" 方法的回调函数中前两个参数值具有相同含义。")]),e._v(" "),v("li",[e._v("尽管 Set 集合更适合用来跟踪多个值，而且又可以通过 forEach() 方法操作集合中的每一个元素，但是不能像访问数组元素那样直接通过索引访问集合中的元素。如有需要，最好先将 Set 集合转换成一个数组，方法可以用展开运算符 "),v("code",[e._v("...")]),e._v(" 或者 "),v("code",[e._v("Array.from()")])])]),e._v(" "),v("blockquote",[v("p",[e._v("展开运算符（展开语法）"),v("code",[e._v("...")]),e._v(" ，可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开（其他的可迭代对象也可以），还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。")])]),e._v(" "),v("h3",{attrs:{id:"weak-set"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weak-set"}},[e._v("#")]),e._v(" Weak Set")]),e._v(" "),v("ul",[v("li",[e._v("Set 类型可以被看作是一个强引用的 Set 集合，Weak Set 集合是弱引用的 Set 集合。Weak Set 集合"),v("strong",[e._v("只存储对象的弱引用，并且不可以存储原始值")]),e._v("；集合中的弱引用如果是对象唯一的引用，则会被垃圾回收并释放相应内存。")]),e._v(" "),v("li",[e._v("Weak Set 集合支持 3 个方法："),v("code",[e._v("add()")]),e._v("、 "),v("code",[e._v("has()")]),e._v("、 "),v("code",[e._v("delete()")])]),e._v(" "),v("li",[e._v("Weak Set 不接受任何原始值，如果 WeakSet 构造函数传入的数组中包含其他非对象值，程序会抛出错误，如果在 WeakSet 实例中，向 "),v("code",[e._v("add()")]),e._v(" 方法传入非对象参数会导致程序报错，而向 "),v("code",[e._v("has()")]),e._v(" 和 "),v("code",[e._v("delete()")]),e._v(" 方法传入非对象参数则会返回 false")]),e._v(" "),v("li",[e._v("Weak Set 集合不可迭代，所以不能被用于 for-of 循环，也不支持 "),v("code",[e._v("forEach()")]),e._v(" 方法")]),e._v(" "),v("li",[e._v("Weak Set 集合不暴露任何迭代器（例如 "),v("code",[e._v("keys()")]),e._v(" 和 "),v("code",[e._v("values()")]),e._v(" 方法），所以无法通过程序本身来检测其中的内容")]),e._v(" "),v("li",[e._v("Weak Set 集合不支持 size 属性")]),e._v(" "),v("li",[e._v("Weak Set 集合的功能看似受限，其实这是为了让它能够正确地处理内存中的数据。总之，如果只需要跟踪对象引用，更应该使用 Weak Set 集合而不是普通的 Set 集合")])]),e._v(" "),v("h3",{attrs:{id:"实用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实用"}},[e._v("#")]),e._v(" 实用")]),e._v(" "),v("p",[e._v("Set 集合中都是相互对立的非重复值，所以可以用于数组去重")]),e._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[e._v("eliminateDuplicates")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("items")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),v("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Set")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("items"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),v("h2",{attrs:{id:"map"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),v("p",[e._v("ECMAScript 6 中的 Map 类型是一种存储着许多"),v("strong",[e._v("键值对")]),e._v("的"),v("strong",[e._v("有序列表")]),e._v("，其中的键名和对应的值"),v("strong",[e._v("支持所有的数据类型")]),e._v("。键名的等价性判断是通过调用 Object.is() 方法实现的，所以数字 "),v("code",[e._v("5")]),e._v(" 与字符串 "),v("code",[e._v('"5"')]),e._v(" 会被判定为两种类型，可以分别作为独立的两个键。")]),e._v(" "),v("h3",{attrs:{id:"map-的一些特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map-的一些特性"}},[e._v("#")]),e._v(" Map 的一些特性")]),e._v(" "),v("ul",[v("li",[e._v("Map 的方法和属性："),v("code",[e._v("set()")]),e._v(" "),v("code",[e._v("get()")]),e._v(" "),v("code",[e._v("delete()")]),e._v(" "),v("code",[e._v("clear()")]),e._v(" "),v("code",[e._v("has()")]),e._v(" "),v("code",[e._v("keys()")]),e._v(" "),v("code",[e._v("values()")]),e._v(" "),v("code",[e._v("entries()")]),e._v(" "),v("code",[e._v("forEach()")]),e._v(" "),v("code",[e._v("size")]),e._v("属性")]),e._v(" "),v("li",[e._v("初始化 Map 构造函数时，需要用到二维数组。数组包裹数组的模式看起来可能有点奇怪，但由于 Map 集合可以接受任意数据类型的键名，为了确保他们在被存储到 Map 集合之前不会被强制转换为其他数据类型，因而只能将它们放在数组中，因为这是唯一一种可以准确地呈现键名类型的方式。")])]),e._v(" "),v("h3",{attrs:{id:"weak-map"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#weak-map"}},[e._v("#")]),e._v(" Weak Map")]),e._v(" "),v("ul",[v("li",[e._v("ECMAScript 6 中的 Weak Map 类型是一种存储着许多键值对的无序列表，列表的键名必须是非 "),v("code",[e._v("null")]),e._v(" 类型的对象，键名对应的值则可以是任意类型")]),e._v(" "),v("li",[e._v("Weak Map 是弱引用 Map 集合，用于存储对象的弱引用，集合中保存这些对象的弱引用，如果在弱引用之外不存在其他的强引用，引擎的垃圾回收机制会自动回收这个对象，同时也会移除 Weak Map 集合中的键值对，但是只有集合的键名遵从这个规则，键名对应的值如果是一个对象，则保存的是对象的强引用，不会触发垃圾回收机制。")]),e._v(" "),v("li",[e._v("Weak Map 集合中的键名必须是一个对象，如果使用非对象键名会报错")]),e._v(" "),v("li",[e._v("Weak Map 集合只支持 4 个可以操作键值对的方法： "),v("code",[e._v("set()")]),e._v(" "),v("code",[e._v("get()")]),e._v(" "),v("code",[e._v("has()")]),e._v(" "),v("code",[e._v("delete()")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);