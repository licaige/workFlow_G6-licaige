(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{680:function(t,a,e){"use strict";e.r(a);var r=e(45),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"nginx-执行流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx-执行流程"}},[t._v("#")]),t._v(" Nginx 执行流程")]),t._v(" "),e("h2",{attrs:{id:"nginx-启动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx-启动"}},[t._v("#")]),t._v(" Nginx 启动")]),t._v(" "),e("h3",{attrs:{id:"nginx-启动、退出时的回调方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx-启动、退出时的回调方法"}},[t._v("#")]),t._v(" Nginx 启动、退出时的回调方法")]),t._v(" "),e("ul",[e("li",[t._v("init_module 在 master 进程中调用")]),t._v(" "),e("li",[t._v("init_process 在 worker 进程中调用")]),t._v(" "),e("li",[t._v("exit_process 在 worker 进程退出时调用")]),t._v(" "),e("li",[t._v("exit_master 在 master 进程退出时调用")])]),t._v(" "),e("h3",{attrs:{id:"nginx-的启动流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx-的启动流程"}},[t._v("#")]),t._v(" Nginx 的启动流程")]),t._v(" "),e("ol",[e("li",[t._v("根据命令行得到配置文件路径")]),t._v(" "),e("li",[t._v("如果处于升级中则监听环境变量里传递的监听句柄")]),t._v(" "),e("li",[t._v("调用所有核心模块的 create_conf 方法生成存放配置项的描述体")]),t._v(" "),e("li",[t._v("针对所有核心模块解析 nginx.conf 配置文件")]),t._v(" "),e("li",[t._v("调用所有核心模块的 init_conf 方法")]),t._v(" "),e("li",[t._v("创建目录、打开文件、初始化共享内存等进程间通信方式")]),t._v(" "),e("li",[t._v("打开由各 Nginx 模块从配置文件中读取到的监听端口")]),t._v(" "),e("li",[t._v("调用所有模块的 init_module 方法（检测 Nginx 的运行方式，单进程还是 master 多进程）")]),t._v(" "),e("li",[t._v("一般会以 master 多进程方式运行 Nginx，进入 master 模式")]),t._v(" "),e("li",[t._v("启动 master 进程")]),t._v(" "),e("li",[t._v("根据 worker_process 启动 worker 进程，调用所有模块的 init_process 方法")]),t._v(" "),e("li",[t._v("启动 cache manager 进程")]),t._v(" "),e("li",[t._v("启动 cache loader 子进程，关闭父进程启动时监听的端口")])]),t._v(" "),e("h2",{attrs:{id:"http-请求处理的-11-个阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-请求处理的-11-个阶段"}},[t._v("#")]),t._v(" HTTP 请求处理的 11 个阶段")]),t._v(" "),e("p",[t._v("HTTP 请求处理的阶段为：POST_READ、SERVER_REWRITE、FIND_CONFIG、REWRITE、POST_REWRITE、PREACCESS、ACCESS、POST_ACCESS、PRECONTENT、CONTENT、LOG")]),t._v(" "),e("h3",{attrs:{id:"_1、postread-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、postread-阶段"}},[t._v("#")]),t._v(" 1、postread 阶段")]),t._v(" "),e("p",[t._v("这个阶段中，获取真实客户端地址的 realip 模块会生效。")]),t._v(" "),e("h4",{attrs:{id:"realip-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#realip-模块"}},[t._v("#")]),t._v(" realip 模块")]),t._v(" "),e("p",[t._v("默认不会编译进 Nginx，需要通过 "),e("code",[t._v("--with-http_realip_module")]),t._v(" 启用功能，作用是修改客户端的地址。")]),t._v(" "),e("p",[t._v("因为模块覆盖了 "),e("code",[t._v("$remote_addr")]),t._v(" ，为了能得到原来的 ip 信息，模块创建了两个变量：")]),t._v(" "),e("ul",[e("li",[t._v("realip_remote_addr")]),t._v(" "),e("li",[t._v("realip_remote_port")])]),t._v(" "),e("p",[t._v("模块有三个指令：")]),t._v(" "),e("ul",[e("li",[t._v("set_real_ip_from：决定什么 ip 地址才是可信的，能替换 "),e("code",[t._v("$remote_addr")]),t._v(" 变量")]),t._v(" "),e("li",[t._v("real_ip_header：从哪个头字段中获取替换的 ip")]),t._v(" "),e("li",[t._v("real_ip_recursive：环回地址，如果 X-Forwarded-For 中的最后一个 ip 是本地 ip，就获取上一个 ip。")])]),t._v(" "),e("h4",{attrs:{id:"网络中存在许多反向代理的情况下-如何拿到真实的用户-ip-地址"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络中存在许多反向代理的情况下-如何拿到真实的用户-ip-地址"}},[t._v("#")]),t._v(" 网络中存在许多反向代理的情况下，如何拿到真实的用户 IP 地址？")]),t._v(" "),e("p",[t._v("例如用户的地址是：122.3.3.2，经过许多反向代理后，"),e("code",[t._v("$remote_addr")]),t._v(" 可能就变成了 "),e("code",[t._v("8.8.8.8")])]),t._v(" "),e("ul",[e("li",[t._v("HTTP 头部 X-Forwarded-For 用于传递 IP，它可以设置多个 IP，用逗号分割。")]),t._v(" "),e("li",[t._v("HTTP 头部 X-Real-IP 用于传递用户 IP，它只能设置一个 IP")])]),t._v(" "),e("p",[t._v("根据 relip 模块的指令，relip 模块可以通过这些 HTTP 头部字段覆写入 binary_remote_addr、remote_addr 变量，使变量的值成为真实的用户 IP。并且只有拿到真实用户的 IP 后做连接限制（如 preaccess 阶段生效的 limit_conn 模块）才有意义。")]),t._v(" "),e("h3",{attrs:{id:"_2、server-rewrite-和-rewrite-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、server-rewrite-和-rewrite-阶段"}},[t._v("#")]),t._v(" 2、server_rewrite 和 rewrite 阶段")]),t._v(" "),e("p",[t._v("server_rewrite 和 rewrite 这两个阶段中，rewrite 模块都会生效。")]),t._v(" "),e("h4",{attrs:{id:"return-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#return-指令"}},[t._v("#")]),t._v(" return 指令")]),t._v(" "),e("p",[t._v("return 指令生效后，后面的指令都不会再执行。")]),t._v(" "),e("p",[t._v("return 指令后面可以是 "),e("code",[t._v("code [text]")]),t._v("、"),e("code",[t._v("code URL")]),t._v("、"),e("code",[t._v("URL")]),t._v("。要特别注意一下使用上下文，没有 http，只能用在 "),e("code",[t._v("server,location,if")]),t._v(" 上下文中。")]),t._v(" "),e("h5",{attrs:{id:"code-返回状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#code-返回状态码"}},[t._v("#")]),t._v(" code 返回状态码")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Nginx 自定义")]),t._v(" "),e("ul",[e("li",[t._v("444 关闭连接，此状态码不会返回到客户端")])])]),t._v(" "),e("li",[e("p",[t._v("HTTP 1.0 标准")]),t._v(" "),e("ul",[e("li",[t._v("301 http1.0 永久重定向，客户端再次访问时会直接访问新地址")]),t._v(" "),e("li",[t._v("302 临时重定向，禁止被缓存")])])]),t._v(" "),e("li",[e("p",[t._v("HTTP 1.1 标准")]),t._v(" "),e("ul",[e("li",[t._v("303 临时重定向，允许改变方法，禁止被缓存")]),t._v(" "),e("li",[t._v("307 临时重定向，不允许改变方法，禁止被缓存")]),t._v(" "),e("li",[t._v("308 永久重定向，不允许改变方法")])]),t._v(" "),e("p",[t._v("如果是 "),e("code",[t._v("return URL;")]),t._v(" ，此时状态码默认是 302。")])])]),t._v(" "),e("h4",{attrs:{id:"server-与-location-块下的-return-指令关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#server-与-location-块下的-return-指令关系"}},[t._v("#")]),t._v(" server 与 location 块下的 return 指令关系?")]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server_name")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("example"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("listen")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  reutrn "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("403")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("404")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"find nothing!"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("code",[t._v("return 403;")]),t._v(" 是在 server_rewrite 阶段，"),e("code",[t._v('return 404 "find nothing!";')]),t._v(" 是在 rewrite 阶段，server_rewrite 阶段先处理，return 指令生效后，后面的指令都不会再执行，并且 return 指令是动作类指令，不会发生继承合并，所以上面的配置会返回 403。")]),t._v(" "),e("h4",{attrs:{id:"return-与-error-page-指令的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#return-与-error-page-指令的关系"}},[t._v("#")]),t._v(" return 与 error_page 指令的关系?")]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server_name")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("example"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("listen")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8080")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("error_page")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("404")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("403.")]),t._v("html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("404")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"find nothing!\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("上面的配置会返回状态码 404，返回的内容是 find nothing!，error_page 不会生效。")]),t._v(" "),e("h4",{attrs:{id:"rewrite-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rewrite-指令"}},[t._v("#")]),t._v(" rewrite 指令")]),t._v(" "),e("p",[t._v("使用反向代理解决跨域时，用到了 rewrite 指令。rewrite 模块提供出来的指令还包括 set、if、break、return。")]),t._v(" "),e("p",[t._v("rewrite 是脚本类型的指令。语法是 "),e("code",[t._v("rewrite regex replacement [flag];")]),t._v("，当 replacement 以 http://或者 https://或者$schema 开头，则直接返回 302 重定向。")]),t._v(" "),e("p",[t._v("rewrite 利用正则表达式和标志位实现 uri 重写和重定向，正则表达式可以用小括号进行变量提取。rewrite 只能放在 server、location 上下文和 if 判断中，并且只能对域名后边的除去传参外的字符串起作用。如果想对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。")]),t._v(" "),e("p",[t._v("例如 "),e("code",[t._v("http://microloan-sms-platform.yxapp.xyz/proxy/sms/task/querydeleted?page=1&pagesize=10")]),t._v(" 只能对 /proxy/sms/task/querydeleted 进行重写。")]),t._v(" "),e("p",[t._v("rewrite 规则后边，通常会带有 flag 标志位：")]),t._v(" "),e("ul",[e("li",[t._v("last：表示持续，用 replacement 这个 URI 进行新的 location 匹配")]),t._v(" "),e("li",[t._v("break：停止当前脚本指令的执行，等价与独立的 break 指令")]),t._v(" "),e("li",[t._v("redirect：返回 302 临时重定向，地址栏会显示跳转后的地址")]),t._v(" "),e("li",[t._v("permanent：返回 301 永久重定向，地址栏会显示跳转后的地址")])]),t._v(" "),e("p",[t._v("last 和 break 的区别：")]),t._v(" "),e("ul",[e("li",[t._v("last 一般写在 server 和 if 中，而 break 一般使用在 location 中")]),t._v(" "),e("li",[t._v("last 不终止重写后的 uri 匹配，即新的 uri 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配")]),t._v(" "),e("li",[t._v("break 和 last 都能阻止继续执行当前上下文后面的 rewrite 指令。")])]),t._v(" "),e("h4",{attrs:{id:"rewrite-和-return-的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rewrite-和-return-的关系"}},[t._v("#")]),t._v(" rewrite 和 return 的关系?")]),t._v(" "),e("p",[t._v("不带 flag 的 rewrite，会跟 return 顺序执行，并以 return 结果为准。如果带了 last 会跳过后面的 return 执行，如果带了 break ，会阻止后面的 return 执行。")]),t._v(" "),e("h3",{attrs:{id:"_3、find-config-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、find-config-阶段"}},[t._v("#")]),t._v(" 3、find_config 阶段")]),t._v(" "),e("p",[t._v("此阶段主要是 location 匹配，可以查看 "),e("RouterLink",{attrs:{to:"/server/nginx/config.html#location-指令规则"}},[t._v("location 配置")])],1),t._v(" "),e("h3",{attrs:{id:"_4、preaccess-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、preaccess-阶段"}},[t._v("#")]),t._v(" 4、preaccess 阶段")]),t._v(" "),e("h4",{attrs:{id:"limit-conn-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-conn-模块"}},[t._v("#")]),t._v(" limit_conn 模块")]),t._v(" "),e("p",[t._v("模块的功能是限制每个客户端的并发连接数，默认编译进 Nginx，生效范围：")]),t._v(" "),e("ul",[e("li",[t._v("全部 worker 进程（基于共享内存）")]),t._v(" "),e("li",[t._v("进入 preaccess 阶段前不生效")]),t._v(" "),e("li",[t._v("并发连接数限制的有效性取决于 key 的设计：一般使用客户端的 ip，所以就需要依赖 postread 阶段的 realip 模块取到真实的 ip")])]),t._v(" "),e("h4",{attrs:{id:"limit-conn-zone-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-conn-zone-指令"}},[t._v("#")]),t._v(" limit_conn_zone 指令")]),t._v(" "),e("p",[t._v("定义共享内存（包括大小），以及 key 关键字。")]),t._v(" "),e("p",[t._v("语法 "),e("code",[t._v("limit_conn_zone key zone=name:size;")]),t._v(" 只能在 http 上下文中使用")]),t._v(" "),e("h4",{attrs:{id:"limit-conn-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-conn-指令"}},[t._v("#")]),t._v(" limit_conn 指令")]),t._v(" "),e("p",[t._v("限制并发连接数。")]),t._v(" "),e("p",[t._v("语法 "),e("code",[t._v("limit_conn zone number;")]),t._v(" 可以用在 http,server,location 上下文中。")]),t._v(" "),e("h4",{attrs:{id:"limit-conn-log-level-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-conn-log-level-指令"}},[t._v("#")]),t._v(" limit_conn_log_level 指令")]),t._v(" "),e("p",[t._v("限制发生时的日志级别，可选的值是 info|notice|warn|error，默认是 error。")]),t._v(" "),e("h4",{attrs:{id:"limit-conn-status-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-conn-status-指令"}},[t._v("#")]),t._v(" limit_conn_status 指令")]),t._v(" "),e("p",[t._v("限制发生时向客户端返回的错误码，默认是 503。")]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("limit_conn_zone")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$binary_remote_addr")]),t._v(" zone"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("addr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v("m"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("server_name")]),t._v(" limit"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("example"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("com"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("error_log")]),t._v(" logs"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("error"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("log info"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    limit_conn_status "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#超限后的状态码")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("limit_conn_log_level")]),t._v(" warn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("limit_conn")]),t._v(" addr "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("limit_rate")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("50")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#限制速度")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h4",{attrs:{id:"limit-req-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-模块"}},[t._v("#")]),t._v(" limit_req 模块")]),t._v(" "),e("p",[t._v("功能是限制每个客户端的每秒处理请求数，默认编译进 Nginx，生效算法是 leaky bucket 算法（漏桶接水把不同的流量转换成均匀的流量），生效范围也是全部 worker 进程（基于共享内存），进入 preaccess 阶段前不生效。")]),t._v(" "),e("h4",{attrs:{id:"limit-req-zone-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-zone-指令"}},[t._v("#")]),t._v(" limit_req_zone 指令")]),t._v(" "),e("p",[t._v("定义共享内存（包括大小），以及 key 关键字和限制速率，语法 "),e("code",[t._v("limit_req_zone key zone=name:size rate=rate;")]),t._v("，只能在 http 上下文中使用。rate 的单位为 r/s（每秒请求）或者 r/m（每分钟请求）。")]),t._v(" "),e("h4",{attrs:{id:"limit-req-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-指令"}},[t._v("#")]),t._v(" limit_req 指令")]),t._v(" "),e("p",[t._v("限制并发连接数，语法 "),e("code",[t._v("limit_req zone=name [burst=number] [nodelay];")]),t._v("，burst 默认为 0（即漏桶的容量），nodelay，对 burst 中的请求不再采用延时处理的做法，而是立即处理。")]),t._v(" "),e("h4",{attrs:{id:"limit-req-log-level-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-log-level-指令"}},[t._v("#")]),t._v(" limit_req_log_level 指令")]),t._v(" "),e("p",[t._v("限制发生时的日志级别")]),t._v(" "),e("h4",{attrs:{id:"limit-req-status-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-status-指令"}},[t._v("#")]),t._v(" limit_req_status 指令")]),t._v(" "),e("p",[t._v("限制发生时向客户端返回的错误码，默认为 503。")]),t._v(" "),e("h4",{attrs:{id:"limit-req-与-limit-conn-配置同时生效时-哪个有效"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#limit-req-与-limit-conn-配置同时生效时-哪个有效"}},[t._v("#")]),t._v(" limit_req 与 limit_conn 配置同时生效时，哪个有效？")]),t._v(" "),e("p",[t._v("limit_req 生效时间在 limit_conn 之前，所以只会看到 limit_req 的配置结果。")]),t._v(" "),e("h3",{attrs:{id:"_5、access-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、access-阶段"}},[t._v("#")]),t._v(" 5、access 阶段")]),t._v(" "),e("h4",{attrs:{id:"access-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#access-模块"}},[t._v("#")]),t._v(" access 模块")]),t._v(" "),e("p",[t._v("限制某些 IP 地址的访问，默认编译进 Nginx，生效范围是：进入 access 之前不生效。")]),t._v(" "),e("h4",{attrs:{id:"allow-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#allow-指令"}},[t._v("#")]),t._v(" allow 指令")]),t._v(" "),e("p",[t._v("允许哪些地址访问，语法 "),e("code",[t._v("allow address|CIDR|unix:|all;")]),t._v("，可以用在 http,server,location,limit_except 上下文中")]),t._v(" "),e("h4",{attrs:{id:"deny-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#deny-指令"}},[t._v("#")]),t._v(" deny 指令")]),t._v(" "),e("p",[t._v("禁止哪些地址访问，语法 "),e("code",[t._v("deny address|CIDR|unix:|all;")]),t._v("，可以用在 http,server,location,limit_except 上下文中")]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("deny")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("192.168")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("allow")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("192.168")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".1")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("24")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("allow")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2001")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("db8"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("32")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("deny")]),t._v(" all"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h4",{attrs:{id:"auth-basic-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-basic-模块"}},[t._v("#")]),t._v(" auth_basic 模块")]),t._v(" "),e("p",[t._v("基于 HTTP Basic Authutication 协议进行用户名密码的认证，模块默认编译进 Nginx。")]),t._v(" "),e("h4",{attrs:{id:"auth-basic-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-basic-指令"}},[t._v("#")]),t._v(" auth_basic 指令")]),t._v(" "),e("p",[t._v("可以设置 string|off，默认为 off")]),t._v(" "),e("h4",{attrs:{id:"auth-basic-user-file"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-basic-user-file"}},[t._v("#")]),t._v(" auth_basic_user_file")]),t._v(" "),e("p",[t._v("用户名和密码配置在哪个文件中。")]),t._v(" "),e("p",[t._v("生成密码文件可以使用生成工具 htpassed，安装依赖包 httpd-tools，然后执行 "),e("code",[t._v("htpasswd -c file -b user pass")])]),t._v(" "),e("h4",{attrs:{id:"auth-request-模块-第三方模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-request-模块-第三方模块"}},[t._v("#")]),t._v(" auth_request 模块（第三方模块）")]),t._v(" "),e("p",[t._v("原理是收到请求后，先把请求 hold，然后生成子请求，通过反向代理技术把请求传递给上游服务。向上游的服务转发请求，若上游服务返回的响应码是 2xx，则继续执行，若上游服务返回的是 401 或 403，则将响应返回给客户端。默认没有编译进 Nginx。")]),t._v(" "),e("h4",{attrs:{id:"auth-request-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-request-指令"}},[t._v("#")]),t._v(" auth_request 指令")]),t._v(" "),e("p",[t._v("语法 "),e("code",[t._v("auth_request uri | off;")]),t._v("，默认为 off。")]),t._v(" "),e("h4",{attrs:{id:"auth-request-set-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auth-request-set-指令"}},[t._v("#")]),t._v(" auth_request_set 指令")]),t._v(" "),e("p",[t._v("语法 "),e("code",[t._v("auth_request_set $variable value;")]),t._v(" 可以根据上游返回的变量来设置新的变量。")]),t._v(" "),e("h4",{attrs:{id:"satisfy-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#satisfy-指令"}},[t._v("#")]),t._v(" satisfy 指令")]),t._v(" "),e("p",[t._v("限制所有 access 阶段模块，例如 access 模块、auth_basic 模块、auth_request 模块等，语法 "),e("code",[t._v("satisfy all | any;")]),t._v("，如果是 all 就表示必须所有配置的 access 模块都通过才能使 access 阶段放行，any 只要有一个 access 模块的配置通过就能在 access 阶段放行。")]),t._v(" "),e("h3",{attrs:{id:"precontent-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#precontent-阶段"}},[t._v("#")]),t._v(" precontent 阶段")]),t._v(" "),e("h4",{attrs:{id:"try-files-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#try-files-指令"}},[t._v("#")]),t._v(" try_files 指令")]),t._v(" "),e("p",[t._v("指令来自 try_files 模块，可以用在 server,location 上下文中，语法是：")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("try_files file... uri;")])]),t._v(" "),e("li",[e("code",[t._v("try_files file... =code")])])]),t._v(" "),e("p",[t._v("try_files 的作用是依次试图访问多个 url 对应的文件（由 root 或者 alias 指令指定），当文件存在时直接返回文件内容，如果所有文件都不存在，则按最后一个 uri 结果或者状态码 code 返回。")]),t._v(" "),e("h4",{attrs:{id:"mirror-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mirror-模块"}},[t._v("#")]),t._v(" mirror 模块")]),t._v(" "),e("p",[t._v("处理请求时，生成子请求访问其他服务（copy 一份流量），对子请求的返回值不做处理。模块默认编译进 Nginx。")]),t._v(" "),e("h4",{attrs:{id:"mirror-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mirror-指令"}},[t._v("#")]),t._v(" mirror 指令")]),t._v(" "),e("p",[t._v("可以设置 uri | off ，默认为 off。")]),t._v(" "),e("h4",{attrs:{id:"mirror-request-body"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mirror-request-body"}},[t._v("#")]),t._v(" mirror_request_body")]),t._v(" "),e("p",[t._v("指定是否需要把请求中的 body 转发给上游服务，默认为 on。")]),t._v(" "),e("h3",{attrs:{id:"content-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#content-阶段"}},[t._v("#")]),t._v(" content 阶段")]),t._v(" "),e("h4",{attrs:{id:"root-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#root-指令"}},[t._v("#")]),t._v(" root 指令")]),t._v(" "),e("p",[t._v("将 url 映射为文件路径，以返回静态文件内容。默认值为 "),e("code",[t._v("root html")]),t._v("，可以用在 http,server,location,if in location 上下文中。")]),t._v(" "),e("p",[e("strong",[t._v("root 会将完整 url 映射进文件路径中。")])]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("root")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("访问：example.com/root/1.txt 文件路径为：html/root/1.txt")]),t._v(" "),e("h4",{attrs:{id:"alias-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#alias-指令"}},[t._v("#")]),t._v(" alias 指令")]),t._v(" "),e("p",[t._v("将 url 映射为文件路径，以返回静态文件内容。没有默认值，只能用在 location 上下文中。")]),t._v(" "),e("p",[e("strong",[t._v("alias 只会将 location 匹配后的 url 映射到文件路径")])]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alias")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alias")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("访问：example.com/alias/1.txt 文件路径为：html/1.txt")]),t._v(" "),e("h4",{attrs:{id:"root-或-alias-配置中-访问目录时-url-最后没有带"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#root-或-alias-配置中-访问目录时-url-最后没有带"}},[t._v("#")]),t._v(" root 或 alias 配置中，访问目录时 URL 最后没有带 "),e("code",[t._v("/")]),t._v("?")]),t._v(" "),e("p",[t._v("static 模块实现了 root/alias 功能时，发现访问目标是目录，但 URL 末尾未加 "),e("code",[t._v("/")]),t._v(" 时，会返回 301 重定向，自动加上 "),e("code",[t._v("/")]),t._v("。")]),t._v(" "),e("p",[t._v("关于重定向后的跳转问题，可以根据 absolute_redirect、port_in_redirect、server_name_in_redirect 来进行配置。")]),t._v(" "),e("h4",{attrs:{id:"content-阶段生成待访问文件的三个相关变量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#content-阶段生成待访问文件的三个相关变量"}},[t._v("#")]),t._v(" content 阶段生成待访问文件的三个相关变量")]),t._v(" "),e("ul",[e("li",[t._v("request_filename 待访问文件的完整路径，包括文件名和扩展名")]),t._v(" "),e("li",[t._v("document_root 由 URI 和 root/alias 规则生成的文件夹路径")]),t._v(" "),e("li",[t._v("realpath_root 将 document_root 中的软链接等换成真实路径")])]),t._v(" "),e("div",{staticClass:"language-nginx extra-class"},[e("pre",{pre:!0,attrs:{class:"language-nginx"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("RealPath"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("alias")]),t._v(" html"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("realpath"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 这是一个软链接指向的是 first 文件夹")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("访问 /RealPath/1.txt 时")]),t._v(" "),e("ul",[e("li",[t._v("request_filename 为 html/realpath/1.txt")]),t._v(" "),e("li",[t._v("document_root 为 html/realpath")]),t._v(" "),e("li",[t._v("realpath_root 为软链接指向的真实路径 html/first")])]),t._v(" "),e("h4",{attrs:{id:"静态文件返回时的-content-tpe-相关"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态文件返回时的-content-tpe-相关"}},[t._v("#")]),t._v(" 静态文件返回时的 content-tpe 相关")]),t._v(" "),e("ul",[e("li",[t._v("types 指令，语法 "),e("code",[t._v("types {...};")]),t._v("，对文件扩展名和文件类型的映射")]),t._v(" "),e("li",[t._v("default_type 指令，语法 "),e("code",[t._v("default_type mime-type;")]),t._v(" 默认为 text/plain")])]),t._v(" "),e("h4",{attrs:{id:"index-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#index-模块"}},[t._v("#")]),t._v(" index 模块")]),t._v(" "),e("p",[t._v("指定访问时返回 index 文件内容，语法 "),e("code",[t._v("index file...;")]),t._v(" 默认是 "),e("code",[t._v("index index.html;")]),t._v("。index 是优先于 auto_index 处理的。")]),t._v(" "),e("h4",{attrs:{id:"auto-index-模块"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#auto-index-模块"}},[t._v("#")]),t._v(" auto_index 模块")]),t._v(" "),e("p",[t._v("当 URL 以 "),e("code",[t._v("/")]),t._v(" 结尾时，尝试以 html/xml/json/jsonp 等格式返回 root/alias 中指向目录的文件。默认编译进了 Nginx。")]),t._v(" "),e("h3",{attrs:{id:"log-阶段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#log-阶段"}},[t._v("#")]),t._v(" log 阶段")]),t._v(" "),e("p",[t._v("log 模块就是把 HTTP 请求相关信息记录到日志中，并且 ngx_http_log_module 无法禁用。")]),t._v(" "),e("h4",{attrs:{id:"log-format-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#log-format-指令"}},[t._v("#")]),t._v(" log_format 指令")]),t._v(" "),e("p",[t._v("语法 "),e("code",[t._v("log_format name [escape=default|json|none] string ...;")]),t._v(" 默认是 "),e("code",[t._v('log_format combined "...";')])]),t._v(" "),e("p",[t._v("默认的 combined 日志格式："),e("code",[t._v("log_format combined '$remote_addr - $remote_user [$time_local]' '\"$request\" $status $body_bytes_sent' '\"$http_referer\"\"$http_user_agent\"';")])]),t._v(" "),e("h4",{attrs:{id:"access-log-指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#access-log-指令"}},[t._v("#")]),t._v(" access_log 指令")]),t._v(" "),e("p",[t._v("语法："),e("code",[t._v("access_log off;")]),t._v(" 或 "),e("code",[t._v("access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]]")])]),t._v(" "),e("p",[t._v("默认值为 "),e("code",[t._v("access_log logs/access.log combined;")])]),t._v(" "),e("ul",[e("li",[t._v("path 路径可以包含变量：不打开 cache 时每记录一条日志都需要打开、关闭日志文件，可以通过 open_log_file_cache 对日志文件名包含变量时进行优化")]),t._v(" "),e("li",[t._v("if 通过变量值控制请求日志是否记录")]),t._v(" "),e("li",[t._v("日志缓存\n"),e("ul",[e("li",[t._v("功能 批量将内存中的日志写入磁盘")]),t._v(" "),e("li",[t._v("写入磁盘的条件\n"),e("ul",[e("li",[t._v("所有待写入磁盘的日志大小超出缓存大小，即 buffer 的大小")]),t._v(" "),e("li",[t._v("达到 flush 指定的过期时间")]),t._v(" "),e("li",[t._v("worker 进程执行 reopen 命令，或者正在关闭")])])])])]),t._v(" "),e("li",[t._v("日志压缩\n"),e("ul",[e("li",[t._v("功能 批量压缩内存中的日志，在写入磁盘")]),t._v(" "),e("li",[t._v("buffer 大小默认为 64KB")]),t._v(" "),e("li",[t._v("压缩级别默认为 1（1 最快压缩率最低，9 最慢压缩率最高）")])])])]),t._v(" "),e("h2",{attrs:{id:"http-过滤相关的模块处理过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http-过滤相关的模块处理过程"}},[t._v("#")]),t._v(" HTTP 过滤相关的模块处理过程")]),t._v(" "),e("p",[t._v("Nginx 的过滤模块就是对 HTTP 请求进行加工处理的。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("接收 HTTP 头部后")])]),t._v(" "),e("li",[e("p",[t._v("会先经过 preaccess 阶段的处理")]),t._v(" "),e("ul",[e("li",[t._v("首先是 limit_req 模块")]),t._v(" "),e("li",[t._v("其次是 limit_conn 模块")])])]),t._v(" "),e("li",[e("p",[t._v("然后经过 access 阶段，access 相关模块会进行处理")])]),t._v(" "),e("li",[e("p",[t._v("然后经过 content 阶段，access pass 后的内容，会先经过 concat 模块处理，然后是 static 模块处理")])]),t._v(" "),e("li",[e("p",[t._v("static 模块处理后的内容，就进入了响应阶段，会经过 header 过滤模块，先经过 image_filter 模块，然后经过 gzip 模块，此时会发送 HTTP 头部")])]),t._v(" "),e("li",[e("p",[t._v("然后就进入到响应 body 的处理中，同样的 image_filter 先处理，然后 gzip 后处理，处理完成后就可以发送 HTTP 响应包体了。")])]),t._v(" "),e("li",[e("p",[t._v("响应的包体会通过以下模块加工响应内容")]),t._v(" "),e("ul",[e("li",[t._v("copy_filter 复制包体内容，必须在 gzip 之前")]),t._v(" "),e("li",[t._v("postpone_filter 处理子请求")]),t._v(" "),e("li",[t._v("header_filter 构造响应头部，例如会添加 server，Nginx 版本号等等")]),t._v(" "),e("li",[t._v("write_filter 发送响应")])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);