(window.webpackJsonp=window.webpackJsonp||[]).push([[118],{581:function(t,n,e){"use strict";e.r(n);var a=e(45),i=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"git-常用命令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-常用命令"}},[t._v("#")]),t._v(" Git 常用命令")]),t._v(" "),e("blockquote",[e("p",[t._v("在使用的任何的 git 命令前，都要切换到 git 项目目录下")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("git init\n初始化一个 git 仓库")])]),t._v(" "),e("li",[e("p",[t._v("git status\n查看当前 git 仓库的状态")])]),t._v(" "),e("li",[e("p",[t._v("git log\n查看提交记录")])])]),t._v(" "),e("h2",{attrs:{id:"添加和提交"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加和提交"}},[t._v("#")]),t._v(" 添加和提交")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git add [files] #把当前文件放入暂存区域\n\ngit add * # 把所有修改文件放入暂存区域\n\ngit add -u [path] # 添加[指定路径下]已跟踪文件\n\n\ngit commit # 给暂存区域生成快照并提交到本地版本库\n\ngit commit [file1] [file2] ...\n# 提交指定文件，对于跟踪过的文件，也可以不用git add，直接git commit file提交到本地版本库\n\ngit commit -m 'message' #添加注释\n\ngit commit -a\n# 跳过使用暂存区域，把所有已经跟踪过的文件暂存起来一并提交,注意是已经跟踪过的，对Untracked files无效\n\ngit commit --amend # 修改最后一次提交,git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。\n\ngit commit -v # 提交时显示所有diff信息\n\n")])])]),e("p",[t._v("相关补充：\n"),e("a",{attrs:{href:"http://yanhaijing.com/git/2016/02/17/my-commit-message/",target:"_blank",rel:"noopener noreferrer"}},[t._v("提交信息规范"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"恢复相关的操作"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#恢复相关的操作"}},[t._v("#")]),t._v(" 恢复相关的操作")]),t._v(" "),e("ul",[e("li",[t._v("文件删除相关")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("rm *&git rm *\n# 第一个命令移除工作区文件，第二个命令本地已经删除了的文件，通过此命令把暂存区的文件也删除了。\n\ngit rm -f *\n# 工作区和暂存区都有文件，运行此命令，会把两个文件都删除\n\ngit rm --cached * # 停止追踪指定文件，但该文件会保留在工作区\n\ngit mv file_from file_to # 重命名跟踪文件\n")])])]),e("ul",[e("li",[t._v("查看历史记录")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git log # 查看最近的提交日志\n# 每次提交都有一个唯一id，可以查看所有提交和他们的id，之后恢复会用到\n\ngit log --pretty=oneline #单行显示提交日志 --pretty: 指定默认不同格式展示信息\n\ngit log --graph # 显示 ASCII 图形表示的分支合并历史。\n\ngit log --graph --oneline   #oneline只是让输出看起来比较舒服,只显示最开始7个字符长度的 SHA-1 校验和。\n\ngit log --author=cfangxu #只看某个人的提交记录\n\ngit log --abbrev-commit # 显示log id的缩写\n\ngit log -num #显示几条log（倒数）\n\ngit log --stat # 简略的显示每次提交的内容更改, 如哪些文件变更,多少删除,多少添加等\n\ngit log --follow [file] # 显示某个文件的版本历史，包括文件改名\n\ngit log -p [file] # 显示指定文件相关的每一次diff\n\ngit log -p -x # 仅显示最近x次的提交,包含每一次的diff\n\n")])])]),e("ul",[e("li",[t._v("搜索调试")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git reflog \t# 查看已经修改的版本号，即使是已经删除的某个分支\n\ngit blame file.name # 快速显示文件的每一行最后一次修改是谁\n\ngit log -S<searchword> --oneline # 在Git的整个历史中进行搜索\n\n")])])]),e("ul",[e("li",[t._v("对比相关")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git show commitId # 查看某一次提交更新了什么\n\ngit diff file #查看指定文件的差异(工作区和暂存区)\n\ngit diff --stat #查看简单的diff结果(工作区和暂存区)\n\ngit diff #比较工作区和暂存区之间的差异\n\ngit diff --cached(--staged) #比较暂存区和版本库之间的差异\n\ngit diff HEAD #比较工作区和版本库之间的差异\n\ngit diff branch #比较工作区和分支之间的差异\n\ngit diff branch1 branch2 #比较两次分支之间的差异\n\ngit diff commit commit #比较两次提交之间的差异\n")])])]),e("ul",[e("li",[t._v("撤销相关")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git reset HEAD <file.name> # 取消已经暂存的文件\n\ngit reset -- <file.name> # 同上,可以用git reset 撤销所有暂存区域文件。\n\ngit reset --hard HEAD <file.name> # 恢复到当前版本库的状态，会覆盖工作区和缓存区的文件\n\ngit reset --hard commit(id) # 通过提交id来恢复之前的某个版本\n\ngit reset --hard  HEAD^ # 跳到之前的一个版本，可以连续使用\n\ngit reset --hard  HEAD~<num> # 跳过num个版本，到想要的版本。\n\ncheckout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。注意当前分支不会发生变化。\n\ngit checkout -- file # 取消在工作区对文件的修改（从暂存区——覆盖工作区）\n\ngit checkout -- . # 从暂存区取出文件覆盖工作区\n\ngit checkout branch|tag|commit -- file_name # 从仓库取出file覆盖当前分支\n\n")])])]),e("h2",{attrs:{id:"分支"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分支"}},[t._v("#")]),t._v(" 分支")]),t._v(" "),e("ul",[e("li",[t._v("创建分支")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git branch # 列出本地分支\n\ngit branch -r # 列出远端分支\n\ngit branch -a # 列出所有分支\n\ngit branch -v # 查看各个分支最后一个提交对象的信息\n\ngit branch --merged # 查看已经合并到当前分支的分支\n\ngit branch --no-merged # 查看未合并到当前分支的分支\n\ngit branch test # 新建test分支\n\ngit branch branch [branch|commit|tag] # 从指定位置出新建分支\n\ngit branch --track branch remote-branch # 新建一个分支，与指定的远程分支建立追踪关系\n\ngit branch -m old new # 重命名分支\n\ngit branch -d test # 删除test分支\n\ngit branch -D test # 强制删除test分支\n\ngit branch --set-upstream-to origin/dev dev # 在dev执行，将本地dev分支与远程dev分支之间建立链接\n\n\ngit checkout test # 切换到test分支\n\ngit checkout -b test # 新建+切换到test分支\n\ngit checkout -b test dev # 基于dev新建test分支，并切换\n\n")])])]),e("ul",[e("li",[t._v("合并分支")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('git merge test # 将test分支合并到当前分支,\n\ngit merge –-no-ff test # 强制指定为非快速合并（no-fast-forward）\n\ngit merge --squash test ## 合并压缩，将test上的commit压缩为一条,svn的在合并分支时采用的就是这种方式，squash会在当前分支新建一个提交节点\nsquash和no-ff非常类似，区别只有一点不会保留对合入分支的引用\n\n\ngit cherry-pick commitId # "复制"一个提交节点并在当前分支做一次完全一样的新提交。\n\ngit cherry-pick -n commit # 拣选多个提交，合并完后可以继续拣选下一个提交\n\n\ngit rebase master # 将master分支上超前的提交，变基到当前分支，本质上，这是线性化的自动的 cherry-pick\n\ngit rebase --onto master 169a6 # 限制回滚范围，rebase当前分支从169a6以后的提交\n\ngit rebase --interactive # 交互模式\n\ngit rebase --continue # 处理完冲突继续合并\n\ngit rebase --skip # 跳过\n\ngit rebase --abort # 取消合并\n')])])]),e("ul",[e("li",[t._v("合并推荐链接：")])]),t._v(" "),e("p",[e("a",{attrs:{href:"http://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/",target:"_blank",rel:"noopener noreferrer"}},[t._v("图解 4 种 git 合并分支方法"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"远程仓库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#远程仓库"}},[t._v("#")]),t._v(" 远程仓库")]),t._v(" "),e("ul",[e("li",[t._v("连接远程仓库")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git remote add origin1 git@github.com:yanhaijing/data.js.git # 添加远程仓库\n\ngit remote # 显示全部源\ngit remote -v # 显示全部源+详细信息\n\ngit remote rename origin1 origin2 # 重命名\n\ngit remote rm origin # 删除\n\ngit remote show origin # 查看指定源的全部信息\n\n# 远程分支删除后，清除还存在的本地分支\ngit remote prune origin --dry-run # prune 是修剪的意思，–dry-run 表示模拟列出将要修剪的 local stale branch ，但不真的执行。\ngit remote prune origin # 移除掉远程分支已经被刪除的 local branch\n")])])]),e("ul",[e("li",[t._v("操作远程仓库")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git fetch origin remotebranch[:localbranch] # 从远端拉取分支[到本地指定分支]\n\ngit merge origin/branch # 合并远端上指定分支\n\ngit pull origin remotebranch:localbranch # 拉取远端分支到本地分支\n\ngit pull origin master --allow-unrelated-histories # 允许拉取远端无关历史的master分支到本地当前分支\n\ngit push origin branch # 将当前分支，推送到远端上指定分支\n\ngit push origin localbranch:remotebranch # 推送本地指定分支，到远端上指定分支\n\ngit push origin :remotebranch # 删除远端指定分支\n\ngit push origin remotebranch --delete # 删除远程分支\n\ngit branch -dr branch # 删除本地和远程分支\n\ngit checkout -b [--track] test origin/dev#基于远端dev分支，新建本地test分支[同时设置跟踪]\n\n")])])]),e("ul",[e("li",[t._v("推荐资源：\n"),e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/06/git_remote.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 远程操作详解"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"工作现场"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#工作现场"}},[t._v("#")]),t._v(" 工作现场")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git stash # 将工作区现场（已跟踪文件）储藏起来，等以后恢复后继续工作。\n\ngit stash list # 查看保存的工作现场\n\ngit stash apply # 恢复工作现场\n\ngit stash drop # 删除stash内容\n\ngit stash pop # 恢复的同时直接删除stash内容\n\ngit stash apply stash@{0} # 恢复指定的工作现场，当你保存了不只一份工作现场时。\n")])])]),e("ul",[e("li",[t._v("链接："),e("a",{attrs:{href:"http://blog.csdn.net/man_help/article/details/51840722",target:"_blank",rel:"noopener noreferrer"}},[t._v("里面有介绍工作现场"),e("OutboundLink")],1)])]),t._v(" "),e("h2",{attrs:{id:"标签"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[t._v("#")]),t._v(" 标签")]),t._v(" "),e("p",[t._v("标签作用: 在开发的一些关键时期,使用标签来记录这些关键时刻, 例如发布版本, 有重大修改, 升级的时候, 会使用标签记录这些时刻, 来永久标记项目中的关键历史时刻;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git tag # 列出现有标签\n\ngit tag v0.1 [branch|commit] # [从指定位置]新建标签\ngit tag -a v0.1 -m 'my version 1.4'#新建带注释标签\n\ngit checkout tagname # 切换到标签\n\ngit push origin v1.5 # 推送分支到源上\n\ngit push origin --tags # 一次性推送所有分支\n\ngit tag -d v0.1 # 删除标签\n\ngit push origin :refs/tags/v0.1 # 删除远程标签\n")])])]),e("p",[t._v("链接："),e("a",{attrs:{href:"http://blog.csdn.net/vipzjyno1/article/details/22098621",target:"_blank",rel:"noopener noreferrer"}},[t._v("里面有关于标签的操作"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"git-rev-parse"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-rev-parse"}},[t._v("#")]),t._v(" git rev-parse")]),t._v(" "),e("p",[e("code",[t._v("git rev-parse")]),t._v(" 是主要用于操作的辅助 "),e("code",[t._v("plumbing")]),t._v(" 命令。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("git rev-parse --git-dir # 显示 .git 目录的绝对/相对路径\n\ngit rev-parse --show-toplevel # 显示工作区的根目录绝对路径\n\ngit rev-parse --show-prefix # 显示相对于工作区根目录的相对路径\n\ngit rev-parse --show-cdup # 显示从当前目录cd up（后退）到工作区根目录的深度\n\ngit rev-parse --local-env-vars # 显示本地的环境变量列表，只列出变量的名称，没有变量的值\n\ngit rev-parse --symbolic --branches # 显示分支\n\ngit rev-parse --symbolic --tags # 显示标签\n\ngit rev-parse HEAD # 显示当前分支最后一次提交的 SHA1 值\n\ngit rev-parse --abbrev-ref HEAD # 显示当前的分支\n")])])]),e("h2",{attrs:{id:"git-的特定场景问题解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#git-的特定场景问题解决"}},[t._v("#")]),t._v(" git 的特定场景问题解决")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git 飞行规则(Flight Rules)"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"推荐资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#推荐资源"}},[t._v("#")]),t._v(" 推荐资源")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://marklodato.github.io/visual-git-guide/index-zh-cn.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("图解 Git"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);n.default=i.exports}}]);