<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@gby/event-bus](./event-bus.md) &gt; [EventBus](./event-bus.eventbus.md) &gt; [dispatchEvent](./event-bus.eventbus.dispatchevent.md)

## EventBus.dispatchEvent() method

派发事件

<b>Signature:</b>

```typescript
dispatchEvent<Type extends KeyOfNonNullableValue<EventMap>>(name: Type, detail: GetEventDetail<EventMap[Type]>): boolean;
```

## Parameters

|  Parameter | Type | Description |
|  --- | --- | --- |
|  name | Type | 事件的名字 |
|  detail | [GetEventDetail](./event-bus.geteventdetail.md)<!-- -->&lt;EventMap\[Type\]&gt; | 事件所携带的数据、信息 |

<b>Returns:</b>

boolean

当该事件是可取消的(cancelable为true)并且至少一个该事件的 事件处理方法 调用了 `Event#preventDefault()`<!-- -->，则返回值为 `false`<!-- -->；否则返回`true`<!-- -->。

## Remarks

如果该被派发的事件的事件类型(event's type)在方法调用之前没有被经过初始化被指定，就会抛出一个 UNSPECIFIED\_EVENT\_TYPE\_ERR 异常，或者如果事件类型是null或一个空字符串. event handler 就会抛出未捕获的异常； 这些 event handlers 运行在一个嵌套的调用栈中： 他们会阻塞调用直到他们处理完毕，但是异常不会冒泡。

\*\*注意：\*\* 与浏览器原生事件不同，原生事件是由DOM派发的，并通过event loop异步调用事件处理程序，而dispatchEvent()则是同步调用事件处理程序。在调用dispatchEvent()后，所有监听该事件的事件处理程序将在代码继续前执行并返回。

