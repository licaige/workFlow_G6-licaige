# VUE相关

## 三种方式编写dom元素

+ template方式

    + _通过vue源码中的代码进行解析_

```
import {createApp} from 'vue'
createApp({
  <!-- 方式一 -->
  template: `<h2>我是vue渲染的</h2>`
  <!-- 方式二 -->
  // template: '#app'
})
```

+ render方式，使用h函数编写渲染内容

    + _h函数返回一个虚拟节点vnode_

+ .vue文件中的template编写模板

    + _vue-loader进行解析_

## vue版本选择

1. vue(.runtime).global(.prod).js :通过浏览器中的
```<script src='...'>```
直接使用
    + 我们之前通过CDN引入和下载的Vue版本就是这个版本;
    + 会暴露一个全局的Vue来使用;
2. vue(.runtime).esm-browser(.prod).js :
    + 用于通过原生ES 模块导入使用（在浏览器中通过```<script type="module">```来使用）。
3. vue(runtime).esm-bundlerjs :
    + 用于 webpack，rollup和 parcel 等构建工具;
    + 构建工具中默认是vue.runtime.esm-bundlerjs;
    + 如果我们需要解析模板template，那么需要手动指定vue.esm-bundlerjs;
4. vue.cjs(.prod).js :
    + 服务器端渲染使用;
    + 通过require()在Nodejs中使用;

+ <span style="color:red">运行时+编译器版本</span>包含了对template模板的编译代码，更完整更大
_不加runtime_

+ <span style="color:red">仅运行时版本</span>运行时可以渲染vue代码，但是打包后vue代码不会渲染
_加runtime_

## vscode开发vue插件

+ Vetur
+ Volar（官方推荐）

## Object.defineProperty和Proxy

proxy方式：
```
const handler = {
    get: function(obj, prop) {
        const v = Reflect.get(obj, prop)
        if (v !== null && typeof v === 'object') {
            return new Proxy(v, handler) // 代理内层（递归）
        } else {
            return v
        }
    },
    set(obj, prop, value) {
        return Reflect.set(obj, prop, value)
    }
}
```

虽然Proxy和Object.defineProperty一样都需要递归拦截属性的get,set，但是<span style="color:red">Proxy只在调用时递归，Object.defineProperty在一开始就递归</span>，所以Proxy性能更高。